CREATE OR REPLACE PACKAGE BODY RENTAL AS

    -- ==================================================================
    PROCEDURE INITIATE_LOCATIONS AS
    BEGIN
        EXECUTE IMMEDIATE 'TRUNCATE TABLE LOCATIONS';
        FOR I IN 1..LOCATIONS_CORRIDOR_NUMBER LOOP
            FOR J IN 1..LOCATIONS_RACK_NUMBER LOOP
                FOR K IN 1..LOCATIONS_SHELF_NUMBER LOOP
                    INSERT INTO LOCATIONS (CORRIDOR, RACK, SHELF) VALUES (I, J, K);
                END LOOP;
            END LOOP;
        END LOOP;
    END INITIATE_LOCATIONS;
    
    -- ==================================================================
    FUNCTION SEARCH_AUTHOR (AUTHOR_TO_SEARCH AUTHOR_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        LAST_NAME_NULL EXCEPTION;
        BIRTH_AFTER_DEATH EXCEPTION;
    BEGIN
        IF AUTHOR_TO_SEARCH.LAST_NAME IS NULL THEN RAISE LAST_NAME_NULL; END IF;
        
        IF AUTHOR_TO_SEARCH.BIRTH_DATE >= AUTHOR_TO_SEARCH.DEATH_DATE THEN
            RAISE BIRTH_AFTER_DEATH;
        END IF;
        
        SELECT AUTHOR_ID INTO TO_RETURN FROM AUTHORS WHERE 
            (UPPER(NVL(FIRST_NAME, '9438H45TG45')) = UPPER(NVL(AUTHOR_TO_SEARCH.FIRST_NAME, '9438H45TG45')))
        AND 
            (UPPER(LAST_NAME) = UPPER(AUTHOR_TO_SEARCH.LAST_NAME))
        AND 
            (NVL(BIRTH_DATE, SYSDATE) = NVL(AUTHOR_TO_SEARCH.BIRTH_DATE, SYSDATE))
        AND 
            (NVL(DEATH_DATE, SYSDATE) = NVL(AUTHOR_TO_SEARCH.DEATH_DATE, SYSDATE));
        
        /*SELECT AUTHOR_ID INTO TO_RETURN FROM AUTHORS WHERE 
            (UPPER(FIRST_NAME) = UPPER(AUTHOR_TO_SEARCH.FIRST_NAME)
            OR ((FIRST_NAME IS NULL) AND (AUTHOR_TO_SEARCH.FIRST_NAME IS NULL)))
        AND 
            (UPPER(LAST_NAME) = UPPER(AUTHOR_TO_SEARCH.LAST_NAME)
            OR ((LAST_NAME IS NULL) AND (AUTHOR_TO_SEARCH.LAST_NAME IS NULL)))
        AND 
            (BIRTH_DATE = AUTHOR_TO_SEARCH.BIRTH_DATE
            OR ((BIRTH_DATE IS NULL) AND (AUTHOR_TO_SEARCH.BIRTH_DATE IS NULL)))
        AND 
            (DEATH_DATE = AUTHOR_TO_SEARCH.DEATH_DATE
            OR ((DEATH_DATE IS NULL) AND (AUTHOR_TO_SEARCH.DEATH_DATE IS NULL)));*/
            
        RETURN TO_RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN LAST_NAME_NULL THEN
            DBMS_OUTPUT.PUT_LINE('SEARCH_AUTHOR() ERROR: LAST NAME CANNOT BE NULL');
        WHEN BIRTH_AFTER_DEATH THEN
            DBMS_OUTPUT.PUT_LINE('SEARCH_AUTHOR() ERROR: BIRTH_DATE MUST BE EARLIER THAN DEATH_DATE');
        --WHEN TOO_MANY_ROWS THEN
            
    END SEARCH_AUTHOR;
    
    FUNCTION SEARCH_AUTHOR(FIRST_NAME VARCHAR2, LAST_NAME VARCHAR2,
        BIRTH_DATE DATE, DEATH_DATE DATE)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        AUTHOR_TO_SEARCH AUTHOR_RECORD;
    BEGIN
        AUTHOR_TO_SEARCH := AUTHOR_RECORD(FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE);
        TO_RETURN := SEARCH_AUTHOR(AUTHOR_TO_SEARCH);
        RETURN TO_RETURN;
    END SEARCH_AUTHOR;
    
    -- ==================================================================
    FUNCTION ADD_AUTHOR (AUTHOR_TO_ADD AUTHOR_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        LAST_NAME_NULL EXCEPTION;
        BIRTH_AFTER_DEATH EXCEPTION;
    BEGIN
        IF AUTHOR_TO_ADD.LAST_NAME IS NULL THEN RAISE LAST_NAME_NULL; END IF;
        
        IF AUTHOR_TO_ADD.BIRTH_DATE >= AUTHOR_TO_ADD.DEATH_DATE THEN
            RAISE BIRTH_AFTER_DEATH;
        END IF;
        
        INSERT INTO AUTHORS 
        (FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE) VALUES
        (AUTHOR_TO_ADD.FIRST_NAME, AUTHOR_TO_ADD.LAST_NAME,
        AUTHOR_TO_ADD.BIRTH_DATE, AUTHOR_TO_ADD.DEATH_DATE)
        RETURNING AUTHOR_ID INTO TO_RETURN;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN LAST_NAME_NULL THEN
            DBMS_OUTPUT.PUT_LINE('ADD_AUTHOR() ERROR: LAST NAME CANNOT BE NULL');
        WHEN BIRTH_AFTER_DEATH THEN
            DBMS_OUTPUT.PUT_LINE('ADD_AUTHOR() ERROR: BIRTH_DATE MUST BE EARLIER THAN DEATH_DATE');
    END;
    
    FUNCTION ADD_AUTHOR(FIRST_NAME VARCHAR2, LAST_NAME VARCHAR2, BIRTH_DATE DATE, DEATH_DATE DATE) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        AUTHOR_TO_ADD AUTHOR_RECORD;
    BEGIN
        AUTHOR_TO_ADD := AUTHOR_RECORD(FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE);
        TO_RETURN := ADD_AUTHOR(AUTHOR_TO_ADD);
        RETURN TO_RETURN;
    END ADD_AUTHOR;
    
    -- ==================================================================
    FUNCTION PICK_AUTHOR (PICKED_AUTHOR_ID NUMBER, AUTHOR_TO_PICK AUTHOR_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        LAST_NAME_NULL EXCEPTION;
        BIRTH_AFTER_DEATH EXCEPTION;
    BEGIN
        IF AUTHOR_TO_PICK.LAST_NAME IS NULL THEN RAISE LAST_NAME_NULL; END IF;
        
        IF AUTHOR_TO_PICK.BIRTH_DATE >= AUTHOR_TO_PICK.DEATH_DATE THEN
            RAISE BIRTH_AFTER_DEATH;
        END IF;
        
        IF PICKED_AUTHOR_ID IS NULL THEN
            TO_RETURN := ADD_AUTHOR(AUTHOR_TO_PICK);
        ELSE
            TO_RETURN := PICKED_AUTHOR_ID;
        END IF;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN LAST_NAME_NULL THEN
            DBMS_OUTPUT.PUT_LINE('ADD_AUTHOR() ERROR: LAST NAME CANNOT BE NULL');
        WHEN BIRTH_AFTER_DEATH THEN
            DBMS_OUTPUT.PUT_LINE('PICK_AUTHOR() ERROR: BIRTH_DATE MUST BE EARLIER THAN DEATH_DATE');
    END PICK_AUTHOR;
    
    FUNCTION PICK_AUTHOR (PICKED_AUTHOR_ID NUMBER, FIRST_NAME VARCHAR2, LAST_NAME VARCHAR2, BIRTH_DATE DATE, DEATH_DATE DATE)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        AUTHOR_TO_PICK AUTHOR_RECORD;
    BEGIN
        AUTHOR_TO_PICK := AUTHOR_RECORD(FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE);
        TO_RETURN := PICK_AUTHOR(PICKED_AUTHOR_ID, AUTHOR_TO_PICK);
        RETURN TO_RETURN;
    END PICK_AUTHOR;
    
    -- ==================================================================
    FUNCTION SEARCH_TITLE (TITLE_TO_SEARCH TITLE_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_NULL EXCEPTION;
        WRONG_AGE_LIMIT EXCEPTION;
    BEGIN
        IF TITLE_TO_SEARCH.TITLE IS NULL THEN RAISE TITLE_NULL; END IF;
        
        IF TITLE_TO_SEARCH.AGE_LIMIT NOT BETWEEN 7 AND 18 THEN
            RAISE WRONG_AGE_LIMIT;
        END IF;
        
        SELECT TITLE_ID INTO TO_RETURN FROM TITLES WHERE 
            (UPPER(TITLE) = UPPER(TITLE_TO_SEARCH.TITLE))
        AND
            (NVL(PUB_DATE, SYSDATE) = NVL(TITLE_TO_SEARCH.PUB_DATE, SYSDATE));
        
        /*SELECT TITLE_ID INTO TO_RETURN FROM TITLES WHERE 
            (UPPER(TITLE) = UPPER(TITLE_TO_SEARCH.TITLE))
            OR ((TITLE IS NULL) AND (TITLE_TO_SEARCH.TITLE IS NULL))
        AND 
            (PUB_DATE = TITLE_TO_SEARCH.PUB_DATE)
            OR ((PUB_DATE IS NULL) AND (TITLE_TO_SEARCH.PUB_DATE IS NULL));*/
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN TITLE_NULL THEN
            DBMS_OUTPUT.PUT_LINE('SEARCH_TITLE() ERROR: TITLE CANNOT BE NULL');
        WHEN WRONG_AGE_LIMIT THEN
            DBMS_OUTPUT.PUT_LINE('SEARCH_AUTHOR() ERROR: AGE LIMIT MUST BE BETWEEN 7 AND 18');
        --WHEN TOO_MANY_ROWS THEN
            
    END SEARCH_TITLE;
    
    FUNCTION SEARCH_TITLE (TITLE VARCHAR2, PUB_DATE DATE, AGE_LIMIT NUMBER, TITLE_DESCRIPTION BLOB)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_TO_SEARCH TITLE_RECORD;
    BEGIN
        TITLE_TO_SEARCH := TITLE_RECORD(TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION);
        TO_RETURN := SEARCH_TITLE(TITLE_TO_SEARCH);
        RETURN TO_RETURN;
    END SEARCH_TITLE;
    
    -- ==================================================================
    FUNCTION ADD_TITLE (TITLE_TO_ADD TITLE_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        TITLE_NULL EXCEPTION;
        WRONG_AGE_LIMIT EXCEPTION;
    BEGIN
        IF TITLE_TO_ADD.TITLE IS NULL THEN RAISE TITLE_NULL; END IF;
        
        IF TITLE_TO_ADD.AGE_LIMIT NOT BETWEEN 7 AND 18 THEN
            RAISE WRONG_AGE_LIMIT;
        END IF;
        
        INSERT INTO TITLES
        (TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION) VALUES
        (TITLE_TO_ADD.TITLE, TITLE_TO_ADD.PUB_DATE,
        TITLE_TO_ADD.AGE_LIMIT, TITLE_TO_ADD.TITLE_DESCRIPTION)
        RETURNING TITLE_ID INTO TO_RETURN;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN TITLE_NULL THEN
            DBMS_OUTPUT.PUT_LINE('ADD_TITLE() ERROR: TITLE CANNOT BE NULL');
        WHEN WRONG_AGE_LIMIT THEN
            DBMS_OUTPUT.PUT_LINE('ADD_AUTHOR() ERROR: AGE LIMIT MUST BE BETWEEN 7 AND 18');
    END ADD_TITLE;
    
    FUNCTION ADD_TITLE(TITLE VARCHAR2, PUB_DATE DATE, AGE_LIMIT NUMBER, TITLE_DESCRIPTION BLOB)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_TO_ADD TITLE_RECORD;
    BEGIN
        TITLE_TO_ADD := TITLE_RECORD(TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION);
        TO_RETURN := ADD_TITLE(TITLE_TO_ADD);
        RETURN TO_RETURN;
    END ADD_TITLE;
    
    -- ==================================================================
    FUNCTION PICK_TITLE (PICKED_TITLE_ID NUMBER, TITLE_TO_PICK TITLE_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        TITLE_NULL EXCEPTION;
        WRONG_AGE_LIMIT EXCEPTION;
    BEGIN
        IF TITLE_TO_PICK.TITLE IS NULL THEN RAISE TITLE_NULL; END IF;
        
        IF TITLE_TO_PICK.AGE_LIMIT NOT BETWEEN 7 AND 18 THEN
            RAISE WRONG_AGE_LIMIT;
        END IF;
        
        IF PICKED_TITLE_ID IS NULL THEN
            TO_RETURN := ADD_TITLE(TITLE_TO_PICK);
        ELSE
            TO_RETURN := PICKED_TITLE_ID;
        END IF;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN TITLE_NULL THEN
            --DBMS_OUTPUT.PUT_LINE('PICK_TITLE() ERROR: TITLE CANNOT BE NULL');
            raise_application_error(-20101, 'PICK_TITLE() ERROR: TITLE CANNOT BE NULL');
        WHEN WRONG_AGE_LIMIT THEN
            DBMS_OUTPUT.PUT_LINE('PICK_AUTHOR() ERROR: AGE LIMIT MUST BE BETWEEN 7 AND 18');
    END PICK_TITLE;
    
    FUNCTION PICK_TITLE(PICKED_TITLE_ID NUMBER, TITLE VARCHAR2, PUB_DATE DATE, AGE_LIMIT NUMBER, TITLE_DESCRIPTION BLOB)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_TO_PICK TITLE_RECORD;
    BEGIN
        TITLE_TO_PICK := TITLE_RECORD(TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION);
        TO_RETURN := PICK_TITLE(PICKED_TITLE_ID, TITLE_TO_PICK);
        RETURN TO_RETURN;
    END PICK_TITLE;
    
    -- ==================================================================
    FUNCTION AUTHORS_TITLES_RELATION (RELATION_AUTHORS ID_ARRAY, RELATION_TITLE_ID NUMBER)
        RETURN NUMBER
    AS
        RELATIONS_CREATED NUMBER := 0;
        CHECK_VAR NUMBER;
        WRONG_TITLE_ID EXCEPTION;
        WRONG_AUTHOR_ID EXCEPTION;
    BEGIN
        SELECT COUNT(TITLE_ID) INTO CHECK_VAR FROM TITLES WHERE TITLE_ID = RELATION_TITLE_ID;
        
        IF CHECK_VAR != 1 THEN RAISE WRONG_TITLE_ID; END IF;
        
        FOR I IN 1..RELATION_AUTHORS.LAST LOOP
            SELECT COUNT(AUTHOR_ID) INTO CHECK_VAR FROM AUTHORS
            WHERE AUTHOR_ID = RELATION_AUTHORS(I);
            
            IF CHECK_VAR != 1 THEN RAISE WRONG_AUTHOR_ID; END IF;
            
            SELECT COUNT(*) INTO CHECK_VAR FROM AUTHORS_TITLES
            WHERE AUTHOR_ID = RELATION_AUTHORS(I) AND TITLE_ID = RELATION_TITLE_ID;
            IF CHECK_VAR = 0 THEN -- JEZELI NIE MA JESZCZE TEJ RELACJI, DODAJ JA
                INSERT INTO AUTHORS_TITLES (AUTHOR_ID, TITLE_ID) VALUES
                (RELATION_AUTHORS(I), RELATION_TITLE_ID);
                RELATIONS_CREATED := RELATIONS_CREATED + 1;
            END IF;
        END LOOP;
        
        RETURN RELATIONS_CREATED;
    EXCEPTION
        WHEN WRONG_TITLE_ID THEN
            DBMS_OUTPUT.PUT_LINE('AUTHORS_TITLES_RELATION() ERROR: 
                TITLE_ID ' || RELATION_TITLE_ID || ' COULD NOT BE FOUND');
        WHEN WRONG_AUTHOR_ID THEN
            DBMS_OUTPUT.PUT_LINE('AUTHORS_TITLES_RELATION() NOT ALL AUTHOR IDS WERE FOUND');
    END AUTHORS_TITLES_RELATION;
    
    -- ==================================================================
    FUNCTION GET_LOCATION_LIST (BOOKS_AMOUNT NUMBER) 
        RETURN LOCATIONS_DICTIONARY
    AS
        ADDED_LOCATION_SPOTS LOCATION_SPOTS := LOCATION_SPOTS();
        TO_RETURN LOCATIONS_DICTIONARY := LOCATIONS_DICTIONARY();
        FREE_SPOTS_IN_LOCATION NUMBER;
        LOCATION_ID_ARRAY ID_ARRAY;
        I NUMBER := 1;
        BOOKS_LEFT NUMBER := BOOKS_AMOUNT;
        
        BOOKS_AMOUNT_LESS_THAN_ONE EXCEPTION;
        RUN_OUT_OF_LOCATIONS EXCEPTION;
    BEGIN
    
        -- WYJATEK JEZELI LICZBA DODAWANYCH KSIAZEK JEST MNIEJSZA NIZ 1
        IF BOOKS_AMOUNT < 1 THEN
            RAISE BOOKS_AMOUNT_LESS_THAN_ONE;
        END IF;
        
        -- SPORZADZ ARRAY WSZYSTKICH LOCATION_ID
        SELECT LOCATION_ID BULK COLLECT INTO LOCATION_ID_ARRAY FROM LOCATIONS ORDER BY CORRIDOR, RACK, SHELF;
    
        -- DOPOKI ZOSTALY KSIAZKI DO ROZMIESZCZENIA
        WHILE BOOKS_LEFT > 0 LOOP
            
            DBMS_OUTPUT.PUT_LINE('LOOP ITERATION NO. ' || I);
            
            -- POLICZ ILE KSIAZEK JUZ LEZY W DANEJ LOKALIZACJI
            SELECT EMPTY_SPOTS_LEFT INTO FREE_SPOTS_IN_LOCATION FROM LOCATIONS
            WHERE LOCATION_ID = LOCATION_ID_ARRAY(I);
            
            DBMS_OUTPUT.PUT_LINE('FREE SPOTS IN LOCATION ' || LOCATION_ID_ARRAY(I) || ': ' ||
                FREE_SPOTS_IN_LOCATION);
            
            -- JEZELI TO OSTATNIE SZTUKI I NIE ZAJMA WSZYSTKICH MIEJSC W LOKALIZACJI
            IF BOOKS_LEFT < FREE_SPOTS_IN_LOCATION THEN
                FREE_SPOTS_IN_LOCATION := BOOKS_LEFT;
            END IF;
            
            DBMS_OUTPUT.PUT_LINE('NUMBER OF SPOTS TO FILL IN LOCATION ' || LOCATION_ID_ARRAY(I) || ': ' ||
                FREE_SPOTS_IN_LOCATION);
            
            
            -- ZAPISZ ILE KSIAZEK UMIESCIMY W DANEJ LOKALIZACJI
            ADDED_LOCATION_SPOTS := LOCATION_SPOTS(LOCATION_ID_ARRAY(I), FREE_SPOTS_IN_LOCATION);
            
            -- ODEJMIJ ILOSC KSIAZEK WLASNIE ROZMIESZCZONYCH
            BOOKS_LEFT := BOOKS_LEFT - FREE_SPOTS_IN_LOCATION;
            DBMS_OUTPUT.PUT_LINE('BOOKS LEFT TO PLACE: ' || BOOKS_LEFT);
            
            -- DODAJ DO ZBIOROWEJ LISTY WSZYSTKICH LOCATION_ID W KTORYCH BEDZIEMY ROZMIESZCZAC
            TO_RETURN.EXTEND(1);
            TO_RETURN(TO_RETURN.LAST) := ADDED_LOCATION_SPOTS;
            
            -- PRZEJDZ DO KOLEJNEJ LOKALIZACJI
            I := I + 1;
            
            -- WYJATEK JEZELI SKONCZYLY SIE LOKALIZACJE
            -- A NADAL NIE ROZMIESCILISMY WSZYSTKICH KSIAZEK
            IF I > LOCATION_ID_ARRAY.LAST THEN
                RAISE RUN_OUT_OF_LOCATIONS;
            END IF;
            
            DBMS_OUTPUT.PUT_LINE('');
            
        END LOOP;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN BOOKS_AMOUNT_LESS_THAN_ONE THEN
             DBMS_OUTPUT.PUT_LINE('GET_LOCATION_LIST() ERROR: AMOUNT OF BOOKS ADDED MUST BE POSITIVE');
        
        WHEN RUN_OUT_OF_LOCATIONS THEN
            DBMS_OUTPUT.PUT_LINE('GET_LOCATION_LIST() ERROR: NO MORE LOCATIONS TO PUT BOOKS IN ('
                || BOOKS_LEFT || ' BOOKS TOO MANY)');
    END GET_LOCATION_LIST;
    
    -- ==================================================================
    FUNCTION ADD_BOOK (BOOK_TO_ADD BOOK_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        BOOK_VALUE_NOT_POSITIVE EXCEPTION;
        CONDITION_WRONG EXCEPTION;
        BUY_DATE_WRONG EXCEPTION;
        LOCATION_WRONG EXCEPTION;
        CHECK_VAR NUMBER;
    BEGIN
        IF NOT(BOOK_TO_ADD.BOOK_VALUE > 0) THEN RAISE BOOK_VALUE_NOT_POSITIVE; END IF;
        IF NOT(BOOK_TO_ADD.CONDITION BETWEEN 1 AND 5) THEN RAISE CONDITION_WRONG; END IF;
        IF NOT(BOOK_TO_ADD.BUY_DATE >= TO_DATE('2022-09-01', 'YYYY-MM-DD')) THEN RAISE BUY_DATE_WRONG; END IF;
        
        SELECT COUNT(LOCATION_ID) INTO CHECK_VAR FROM LOCATIONS
        WHERE LOCATION_ID = BOOK_TO_ADD.LOCATION_ID;
        
        IF CHECK_VAR != 1 THEN RAISE LOCATION_WRONG; END IF;
    
        INSERT INTO BOOKS (TITLE_ID, BORROW_STATE, LOCATION_ID, BOOK_VALUE, CONDITION, BUY_DATE)
        VALUES (BOOK_TO_ADD.TITLE_ID, 'IN STORAGE', BOOK_TO_ADD.LOCATION_ID, 
        BOOK_TO_ADD.BOOK_VALUE, BOOK_TO_ADD.CONDITION, BOOK_TO_ADD.BUY_DATE)
        RETURNING BOOK_ID INTO TO_RETURN;
        
        UPDATE LOCATIONS SET EMPTY_SPOTS_LEFT = EMPTY_SPOTS_LEFT - 1
        WHERE LOCATION_ID = BOOK_TO_ADD.LOCATION_ID;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN BOOK_VALUE_NOT_POSITIVE THEN
             DBMS_OUTPUT.PUT_LINE('ADD_BOOK() ERROR: BOOK_VALUE MUST BE POSITIVE');
        WHEN CONDITION_WRONG THEN
             DBMS_OUTPUT.PUT_LINE('ADD_BOOK() ERROR: CONDITION MUST BE BETWEEN 1 AND 5');
        WHEN BUY_DATE_WRONG THEN
             DBMS_OUTPUT.PUT_LINE('ADD_BOOK() ERROR: BUY_DATE MUST BE 2022-09-01 OR LATER');
        WHEN LOCATION_WRONG THEN
             DBMS_OUTPUT.PUT_LINE('ADD_BOOK() ERROR: LOCATION_ID ' || BOOK_TO_ADD.LOCATION_ID || ' NOT FOUND');
    END ADD_BOOK;
    
    FUNCTION ADD_BOOK (TITLE_ID NUMBER, LOCATION_ID NUMBER, BOOK_VALUE NUMBER, 
        CONDITION NUMBER, BUY_DATE DATE)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        BOOK_TO_ADD BOOK_RECORD;
    BEGIN
        BOOK_TO_ADD := BOOK_RECORD(TITLE_ID, LOCATION_ID, BOOK_VALUE, CONDITION,
        BUY_DATE);
        TO_RETURN := ADD_BOOK(BOOK_TO_ADD);
        RETURN TO_RETURN;
    END ADD_BOOK;
    
    -- ==================================================================
    FUNCTION ADD_BOOKS (TITLE_ID NUMBER,
        HOW_MANY_BOOKS NUMBER,
        ADDED_BOOKS_LOCATIONS LOCATIONS_DICTIONARY,
        ADDED_BOOKS_VALUE NUMBER,
        ADDED_BOOKS_CONDITION NUMBER,
        ADDED_BOOKS_BUY_DATE DATE
    ) RETURN ID_ARRAY
    AS
        TO_RETURN ID_ARRAY := ID_ARRAY();
        CURRENT_BOOK_ID NUMBER;
        CURRENT_LOCATION_ID NUMBER := ADDED_BOOKS_LOCATIONS(1).LOCATION_ID;
        BOOKS_LEFT NUMBER := HOW_MANY_BOOKS;
        LOCATION_INDEX NUMBER := 1;
        SPOTS_LEFT NUMBER := ADDED_BOOKS_LOCATIONS(1).NUMBER_OF_EMPTY_SPOTS;
        BOOK_TO_ADD BOOK_RECORD;
    BEGIN
        WHILE BOOKS_LEFT > 0 LOOP
            DBMS_OUTPUT.PUT_LINE('LOCATION INDEX: ' || LOCATION_INDEX);
            DBMS_OUTPUT.PUT_LINE('SPOTS LEFT IN INDEX: ' || SPOTS_LEFT);
            -- JEZELI NIE MA MIEJSCA W DANEJ LOKALIZACJI, SPROBUJ KOLEJNA
            WHILE SPOTS_LEFT = 0 LOOP
                LOCATION_INDEX := LOCATION_INDEX + 1;
                SPOTS_LEFT := ADDED_BOOKS_LOCATIONS(LOCATION_INDEX).NUMBER_OF_EMPTY_SPOTS;
            END LOOP;
            
            -- ZAPISZ OBECNE LOCATION_ID
            CURRENT_LOCATION_ID := ADDED_BOOKS_LOCATIONS(LOCATION_INDEX).LOCATION_ID;
            
            -- PRZYGOTUJ KROTKE POJEDYNCZEJ KSIAZKI DO DODANIA
            BOOK_TO_ADD := BOOK_RECORD(TITLE_ID, CURRENT_LOCATION_ID,
            ADDED_BOOKS_VALUE, ADDED_BOOKS_CONDITION, ADDED_BOOKS_BUY_DATE);
            
            -- DODAJ KROTKE POJEDYNCZEJ KSIAZKI
            CURRENT_BOOK_ID := ADD_BOOK(BOOK_TO_ADD);
            
            -- DOPISZ ID DODANEJ KSIAZKI DO LISTY ID
            TO_RETURN.EXTEND(1);
            TO_RETURN(TO_RETURN.LAST) := CURRENT_BOOK_ID;
            
            BOOKS_LEFT := BOOKS_LEFT - 1;
            SPOTS_LEFT := SPOTS_LEFT - 1;
            
            DBMS_OUTPUT.PUT_LINE('JUST ADDED BOOK ID: ' || CURRENT_BOOK_ID);
            DBMS_OUTPUT.PUT_LINE('BOOKS LEFT TO ADD: ' || BOOKS_LEFT);
            DBMS_OUTPUT.PUT_LINE('');
        END LOOP;
        
        RETURN TO_RETURN;
    END ADD_BOOKS;
    
    -- ==================================================================
    FUNCTION GET_LOCATION_LOCKHANDLE RETURN VARCHAR2 IS
    BEGIN
        IF LOCATION_LOCKHANDLE IS NULL THEN
            DBMS_LOCK.ALLOCATE_UNIQUE(
                LOCKNAME => LOCATION_LOCKNAME,
                LOCKHANDLE => LOCATION_LOCKHANDLE);
        END IF;
        
        RETURN LOCATION_LOCKHANDLE;
    END GET_LOCATION_LOCKHANDLE;
    
    -- ==================================================================
    PROCEDURE LOCK_LOCATION (T_LOCATION_ID NUMBER) 
    IS
        TEMP_NUM NUMBER;
    BEGIN
        SELECT 1 INTO TEMP_NUM FROM LOCATIONS
        WHERE LOCATION_ID = T_LOCATION_ID
        FOR UPDATE NOWAIT;
    END LOCK_LOCATION;
    
    -- ==================================================================
    /*
    FUNCTION LOCK_LOCATION RETURN INTEGER IS
        TEMP_LOCKHANDLE LOCATION_LOCKHANDLE%TYPE := GET_LOCATION_LOCKHANDLE;
        RETURN_CODE INTEGER;
    BEGIN
        RETURN_CODE := DBMS_LOCK.REQUEST(
                        LOCKHANDLE => TEMP_LOCKHANDLE,
                        LOCKMODE => DBMS_LOCK.X_MODE,
                        TIMEOUT => 60,
                        RELEASE_ON_COMMIT => TRUE);
                        
        RETURN RETURN_CODE;
    END LOCK_LOCATION; */
    
    -- ==================================================================
    /*
    FUNCTION RELEASE_LOCATION RETURN INTEGER IS
        TEMP_LOCKHANDLE LOCATION_LOCKHANDLE%TYPE := GET_LOCATION_LOCKHANDLE;
        RETURN_CODE INTEGER;
    BEGIN
        RETURN_CODE := DBMS_LOCK.RELEASE(
                        LOCKHANDLE => TEMP_LOCKHANDLE);
                        
        RETURN RETURN_CODE;
    END RELEASE_LOCATION; */
        
END RENTAL;
/

