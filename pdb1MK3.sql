CREATE OR REPLACE PACKAGE BODY RENTAL AS

    ERR_20000 EXCEPTION;
    ERR_20001 EXCEPTION;
    ERR_20002 EXCEPTION;
    ERR_20003 EXCEPTION;
    ERR_20004 EXCEPTION;
    ERR_20005 EXCEPTION;
    ERR_20006 EXCEPTION;
    ERR_20007 EXCEPTION;
    ERR_20008 EXCEPTION;
    ERR_20009 EXCEPTION;
    ERR_20010 EXCEPTION;
    ERR_20011 EXCEPTION;
    ERR_20012 EXCEPTION;
    ERR_20013 EXCEPTION;
    ERR_20014 EXCEPTION;
    ERR_20015 EXCEPTION;
    ERR_20016 EXCEPTION;
    ERR_20017 EXCEPTION;
    ERR_20018 EXCEPTION;
    ERR_20019 EXCEPTION;
    ERR_20020 EXCEPTION;
    
    ERR_20050 EXCEPTION;
    ERR_20051 EXCEPTION;
    ERR_20052 EXCEPTION;
    ERR_20053 EXCEPTION;
    ERR_20054 EXCEPTION;
    ERR_20055 EXCEPTION;
    ERR_20056 EXCEPTION;
    ERR_20057 EXCEPTION;
    ERR_20058 EXCEPTION;
    ERR_20059 EXCEPTION;
    ERR_20060 EXCEPTION;

    
    PRAGMA EXCEPTION_INIT(ERR_20000, -20000);
    PRAGMA EXCEPTION_INIT(ERR_20001, -20001);
    PRAGMA EXCEPTION_INIT(ERR_20002, -20002);
    PRAGMA EXCEPTION_INIT(ERR_20003, -20003);
    PRAGMA EXCEPTION_INIT(ERR_20004, -20004);
    PRAGMA EXCEPTION_INIT(ERR_20005, -20005);
    PRAGMA EXCEPTION_INIT(ERR_20006, -20006);
    PRAGMA EXCEPTION_INIT(ERR_20007, -20007);
    PRAGMA EXCEPTION_INIT(ERR_20008, -20008);
    PRAGMA EXCEPTION_INIT(ERR_20009, -20009);
    PRAGMA EXCEPTION_INIT(ERR_20010, -20010);
    PRAGMA EXCEPTION_INIT(ERR_20011, -20011);
    PRAGMA EXCEPTION_INIT(ERR_20012, -20012);
    PRAGMA EXCEPTION_INIT(ERR_20013, -20013);
    PRAGMA EXCEPTION_INIT(ERR_20014, -20014);
    PRAGMA EXCEPTION_INIT(ERR_20015, -20015);
    PRAGMA EXCEPTION_INIT(ERR_20016, -20016);
    PRAGMA EXCEPTION_INIT(ERR_20017, -20017);
    PRAGMA EXCEPTION_INIT(ERR_20018, -20018);
    PRAGMA EXCEPTION_INIT(ERR_20019, -20019);
    PRAGMA EXCEPTION_INIT(ERR_20020, -20020);
    
    PRAGMA EXCEPTION_INIT(ERR_20050, -20050);
    PRAGMA EXCEPTION_INIT(ERR_20051, -20051);
    PRAGMA EXCEPTION_INIT(ERR_20052, -20052);
    PRAGMA EXCEPTION_INIT(ERR_20053, -20053);
    PRAGMA EXCEPTION_INIT(ERR_20054, -20054);
    PRAGMA EXCEPTION_INIT(ERR_20055, -20055);
    PRAGMA EXCEPTION_INIT(ERR_20056, -20056);
    PRAGMA EXCEPTION_INIT(ERR_20057, -20057);
    PRAGMA EXCEPTION_INIT(ERR_20058, -20058);
    PRAGMA EXCEPTION_INIT(ERR_20059, -20059);
    PRAGMA EXCEPTION_INIT(ERR_20060, -20060);

    -- ==================================================================
    FUNCTION DELIVERY (T_DELIVERY_DICTIONARY DELIVERY_DICTIONARY)
        RETURN ID_ARRAY
    AS
        DELIVERY_PART_ID_ARRAY ID_ARRAY;
        TOTAL_ID_ARRAY ID_ARRAY;
        I NUMBER := 1;
    BEGIN
        TOTAL_ID_ARRAY := ID_ARRAY();
        WHILE I <= T_DELIVERY_DICTIONARY.LAST LOOP
            SAVEPOINT T_SAVEPOINT;
            BEGIN
                DELIVERY_PART_ID_ARRAY := DELIVERY(T_DELIVERY_DICTIONARY(I));
                TOTAL_ID_ARRAY := TOTAL_ID_ARRAY MULTISET UNION DELIVERY_PART_ID_ARRAY;
            EXCEPTION
                WHEN ERR_20000 OR ERR_20001 OR ERR_20002 OR ERR_20003 OR ERR_20004 OR 
                ERR_20005 OR ERR_20006 OR ERR_20007 OR ERR_20008 OR ERR_20009 OR 
                ERR_20010 OR ERR_20011 OR ERR_20012 OR ERR_20013 OR ERR_20014 OR 
                ERR_20015 OR ERR_20016 OR ERR_20017 OR ERR_20018 OR ERR_20019 OR 
                ERR_20020 THEN
                    DBMS_OUTPUT.PUT_LINE(SQLERRM);
                    DBMS_OUTPUT.PUT_LINE('SKIPPING THIS DELIVERY_PART AND ROLLING BACK');
                    DBMS_OUTPUT.PUT_LINE('');
                    ROLLBACK TO T_SAVEPOINT;
                when others then
                    DBMS_OUTPUT.PUT_LINE(Dbms_utility.Format_error_backtrace);
            END;
            I := I + 1;
        END LOOP;
        RETURN TOTAL_ID_ARRAY;
    END DELIVERY;
    
    FUNCTION DELIVERY (T_DELIVERY_PART DELIVERY_PART)
        RETURN ID_ARRAY
    AS
        T_AUTHOR_ID_ARRAY ID_ARRAY := ID_ARRAY();
        T_TITLE_ID NUMBER;
        T_LOCATIONS_DICTIONARY LOCATIONS_DICTIONARY;
        T_BOOK_ID_ARRAY ID_ARRAY := ID_ARRAY();
        T_BUY_DATE DATE;
        RELATIONS_CREATED NUMBER;
        
        RET_DELI_ID NUMBER;
    BEGIN
        FOR I IN 1..T_DELIVERY_PART.T_AUTHORS.LAST LOOP
            T_AUTHOR_ID_ARRAY.EXTEND(1);
            T_AUTHOR_ID_ARRAY(I) := PICK_AUTHOR(
                                                SEARCH_AUTHOR(T_DELIVERY_PART.T_AUTHORS(I))
                                               ,T_DELIVERY_PART.T_AUTHORS(I));
        END LOOP;
        
        T_TITLE_ID := PICK_TITLE(
                                 SEARCH_TITLE(T_DELIVERY_PART.T_TITLE)
                                ,T_DELIVERY_PART.T_TITLE);
                                
        RELATIONS_CREATED := AUTHORS_TITLES_RELATION(
                                                     T_AUTHOR_ID_ARRAY
                                                    ,T_TITLE_ID);
        
        T_LOCATIONS_DICTIONARY := GET_LOCATION_LIST(T_DELIVERY_PART.T_AMOUNT);
        
        DBMS_OUTPUT.PUT_LINE('DICTIONARY OF LOCATIONS RETURNED: ');
        FOR I IN 1..T_LOCATIONS_DICTIONARY.LAST LOOP
            DBMS_OUTPUT.PUT_LINE(T_LOCATIONS_DICTIONARY(I).LOCATION_ID || ': ' ||
                T_LOCATIONS_DICTIONARY(I).NUMBER_OF_EMPTY_SPOTS);
        END LOOP;
        DBMS_OUTPUT.PUT_LINE('');
        
        IF T_DELIVERY_PART.T_ADDED_BOOKS_BUY_DATE IS NULL THEN
            T_BUY_DATE := SYSDATE;
        ELSE
            T_BUY_DATE := T_DELIVERY_PART.T_ADDED_BOOKS_BUY_DATE;
        END IF;
        
        INSERT INTO DELIVERIES (DELIVERY_DATE, TITLE_ID, AMOUNT) VALUES
        (SYSDATE, T_TITLE_ID, T_DELIVERY_PART.T_AMOUNT) 
        RETURNING DELIVERY_ID INTO RET_DELI_ID;
        
        T_BOOK_ID_ARRAY := ADD_BOOKS(
                                     T_TITLE_ID
                                    ,T_LOCATIONS_DICTIONARY
                                    ,T_DELIVERY_PART.T_AMOUNT
                                    ,T_DELIVERY_PART.T_ADDED_BOOKS_VALUE
                                    ,T_DELIVERY_PART.T_ADDED_BOOKS_CONDITION
                                    ,T_BUY_DATE
                                    ,RET_DELI_ID);
        
        DBMS_OUTPUT.PUT_LINE('DELIVERY_ID: ' || TO_CHAR(RET_DELI_ID));
                                    
        RETURN T_BOOK_ID_ARRAY;
    END DELIVERY;
    
    -- ==================================================================
    PROCEDURE INITIATE_LOCATIONS AS
    BEGIN
        EXECUTE IMMEDIATE 'TRUNCATE TABLE LOCATIONS';
        FOR I IN 1..LOCATIONS_CORRIDOR_NUMBER LOOP
            FOR J IN 1..LOCATIONS_RACK_NUMBER LOOP
                FOR K IN 1..LOCATIONS_SHELF_NUMBER LOOP
                    INSERT INTO LOCATIONS (CORRIDOR, RACK, SHELF) VALUES (I, J, K);
                END LOOP;
            END LOOP;
        END LOOP;
    END INITIATE_LOCATIONS;
    
    -- ==================================================================
    FUNCTION SEARCH_AUTHOR (AUTHOR_TO_SEARCH AUTHOR_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        LAST_NAME_NULL EXCEPTION;
        BIRTH_AFTER_DEATH EXCEPTION;
        BIRTH_DEATH_FUTURE EXCEPTION;
    BEGIN
        IF AUTHOR_TO_SEARCH.LAST_NAME IS NULL THEN RAISE LAST_NAME_NULL; END IF;
        
        IF AUTHOR_TO_SEARCH.BIRTH_DATE >= AUTHOR_TO_SEARCH.DEATH_DATE THEN
            RAISE BIRTH_AFTER_DEATH;
        END IF;
        
        IF AUTHOR_TO_SEARCH.BIRTH_DATE > SYSDATE 
        OR AUTHOR_TO_SEARCH.DEATH_DATE > SYSDATE THEN
            RAISE BIRTH_DEATH_FUTURE;
        END IF;
        
        SELECT AUTHOR_ID INTO TO_RETURN FROM AUTHORS WHERE 
            (UPPER(NVL(FIRST_NAME, '9438H45TG45')) = UPPER(NVL(AUTHOR_TO_SEARCH.FIRST_NAME, '9438H45TG45')))
        AND 
            (UPPER(LAST_NAME) = UPPER(AUTHOR_TO_SEARCH.LAST_NAME))
        AND 
            (NVL(BIRTH_DATE, SYSDATE) = NVL(AUTHOR_TO_SEARCH.BIRTH_DATE, SYSDATE))
        AND 
            (NVL(DEATH_DATE, SYSDATE) = NVL(AUTHOR_TO_SEARCH.DEATH_DATE, SYSDATE));
        
        /*SELECT AUTHOR_ID INTO TO_RETURN FROM AUTHORS WHERE 
            (UPPER(FIRST_NAME) = UPPER(AUTHOR_TO_SEARCH.FIRST_NAME)
            OR ((FIRST_NAME IS NULL) AND (AUTHOR_TO_SEARCH.FIRST_NAME IS NULL)))
        AND 
            (UPPER(LAST_NAME) = UPPER(AUTHOR_TO_SEARCH.LAST_NAME)
            OR ((LAST_NAME IS NULL) AND (AUTHOR_TO_SEARCH.LAST_NAME IS NULL)))
        AND 
            (BIRTH_DATE = AUTHOR_TO_SEARCH.BIRTH_DATE
            OR ((BIRTH_DATE IS NULL) AND (AUTHOR_TO_SEARCH.BIRTH_DATE IS NULL)))
        AND 
            (DEATH_DATE = AUTHOR_TO_SEARCH.DEATH_DATE
            OR ((DEATH_DATE IS NULL) AND (AUTHOR_TO_SEARCH.DEATH_DATE IS NULL)));*/
            
        RETURN TO_RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN LAST_NAME_NULL THEN
            RAISE_APPLICATION_ERROR(-20000, 'LAST NAME OF THE AUTHOR CANNOT BE NULL');
        WHEN BIRTH_AFTER_DEATH THEN
            RAISE_APPLICATION_ERROR(-20001, 'BIRTH DATE OF THE AUTHOR CANNOT BE LATER OR EQUAL TO THEIR DEATH DATE');
        WHEN BIRTH_DEATH_FUTURE THEN
            RAISE_APPLICATION_ERROR(-20002, 'BIRTH DATE OR DEATH DATE OF THE AUTHOR IS LATER THAN PRESENT');
        --WHEN TOO_MANY_ROWS THEN
            
    END SEARCH_AUTHOR;
    
    FUNCTION SEARCH_AUTHOR (FIRST_NAME VARCHAR2, LAST_NAME VARCHAR2,
        BIRTH_DATE DATE, DEATH_DATE DATE)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        AUTHOR_TO_SEARCH AUTHOR_RECORD;
    BEGIN
        AUTHOR_TO_SEARCH := AUTHOR_RECORD(FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE);
        TO_RETURN := SEARCH_AUTHOR(AUTHOR_TO_SEARCH);
        RETURN TO_RETURN;
    END SEARCH_AUTHOR;
    
    -- ==================================================================
    FUNCTION ADD_AUTHOR (AUTHOR_TO_ADD AUTHOR_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        LAST_NAME_NULL EXCEPTION;
        BIRTH_AFTER_DEATH EXCEPTION;
        BIRTH_DEATH_FUTURE EXCEPTION;
    BEGIN
        IF AUTHOR_TO_ADD.LAST_NAME IS NULL THEN RAISE LAST_NAME_NULL; END IF;
        
        IF AUTHOR_TO_ADD.BIRTH_DATE >= AUTHOR_TO_ADD.DEATH_DATE THEN
            RAISE BIRTH_AFTER_DEATH;
        END IF;
        
        IF AUTHOR_TO_ADD.BIRTH_DATE > SYSDATE 
        OR AUTHOR_TO_ADD.DEATH_DATE > SYSDATE THEN
            RAISE BIRTH_DEATH_FUTURE;
        END IF;
        
        INSERT INTO AUTHORS 
        (FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE) VALUES
        (AUTHOR_TO_ADD.FIRST_NAME, AUTHOR_TO_ADD.LAST_NAME,
        AUTHOR_TO_ADD.BIRTH_DATE, AUTHOR_TO_ADD.DEATH_DATE)
        RETURNING AUTHOR_ID INTO TO_RETURN;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN LAST_NAME_NULL THEN
            RAISE_APPLICATION_ERROR(-20000, 'LAST NAME OF THE AUTHOR CANNOT BE NULL');
        WHEN BIRTH_AFTER_DEATH THEN
            RAISE_APPLICATION_ERROR(-20001, 'BIRTH DATE OF THE AUTHOR CANNOT BE LATER OR EQUAL TO THEIR DEATH DATE');
        WHEN BIRTH_DEATH_FUTURE THEN
            RAISE_APPLICATION_ERROR(-20002, 'BIRTH DATE OR DEATH DATE OF THE AUTHOR IS LATER THAN PRESENT');
    END;
    
    FUNCTION ADD_AUTHOR (FIRST_NAME VARCHAR2, LAST_NAME VARCHAR2, BIRTH_DATE DATE, DEATH_DATE DATE) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        AUTHOR_TO_ADD AUTHOR_RECORD;
    BEGIN
        AUTHOR_TO_ADD := AUTHOR_RECORD(FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE);
        TO_RETURN := ADD_AUTHOR(AUTHOR_TO_ADD);
        RETURN TO_RETURN;
    END ADD_AUTHOR;
    
    -- ==================================================================
    FUNCTION PICK_AUTHOR (PICKED_AUTHOR_ID NUMBER, AUTHOR_TO_PICK AUTHOR_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        LAST_NAME_NULL EXCEPTION;
        BIRTH_AFTER_DEATH EXCEPTION;
        BIRTH_DEATH_FUTURE EXCEPTION;
    BEGIN
        IF AUTHOR_TO_PICK.LAST_NAME IS NULL THEN RAISE LAST_NAME_NULL; END IF;
        
        IF AUTHOR_TO_PICK.BIRTH_DATE >= AUTHOR_TO_PICK.DEATH_DATE THEN
            RAISE BIRTH_AFTER_DEATH;
        END IF;
        
        IF AUTHOR_TO_PICK.BIRTH_DATE > SYSDATE 
        OR AUTHOR_TO_PICK.DEATH_DATE > SYSDATE THEN
            RAISE BIRTH_DEATH_FUTURE;
        END IF;
        
        IF PICKED_AUTHOR_ID IS NULL THEN
            TO_RETURN := ADD_AUTHOR(AUTHOR_TO_PICK);
        ELSE
            TO_RETURN := PICKED_AUTHOR_ID;
        END IF;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN LAST_NAME_NULL THEN
            RAISE_APPLICATION_ERROR(-20000, 'LAST NAME OF THE AUTHOR CANNOT BE EMPTY');
        WHEN BIRTH_AFTER_DEATH THEN
            RAISE_APPLICATION_ERROR(-20001, 'BIRTH DATE OF THE AUTHOR CANNOT BE LATER OR EQUAL TO THEIR DEATH DATE');
        WHEN BIRTH_DEATH_FUTURE THEN
            RAISE_APPLICATION_ERROR(-20002, 'BIRTH DATE OR DEATH DATE OF THE AUTHOR IS LATER THAN PRESENT');
    END PICK_AUTHOR;
    
    FUNCTION PICK_AUTHOR (PICKED_AUTHOR_ID NUMBER, FIRST_NAME VARCHAR2, LAST_NAME VARCHAR2, BIRTH_DATE DATE, DEATH_DATE DATE)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        AUTHOR_TO_PICK AUTHOR_RECORD;
    BEGIN
        AUTHOR_TO_PICK := AUTHOR_RECORD(FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE);
        TO_RETURN := PICK_AUTHOR(PICKED_AUTHOR_ID, AUTHOR_TO_PICK);
        RETURN TO_RETURN;
    END PICK_AUTHOR;
    
    -- ==================================================================
    FUNCTION SEARCH_TITLE (TITLE_TO_SEARCH TITLE_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_NULL EXCEPTION;
        WRONG_AGE_LIMIT EXCEPTION;
    BEGIN
        IF TITLE_TO_SEARCH.TITLE IS NULL THEN RAISE TITLE_NULL; END IF;
        
        IF TITLE_TO_SEARCH.AGE_LIMIT NOT BETWEEN 7 AND 18 THEN
            RAISE WRONG_AGE_LIMIT;
        END IF;
        
        SELECT TITLE_ID INTO TO_RETURN FROM TITLES WHERE 
            (UPPER(TITLE) = UPPER(TITLE_TO_SEARCH.TITLE))
        AND
            (NVL(PUB_DATE, SYSDATE) = NVL(TITLE_TO_SEARCH.PUB_DATE, SYSDATE));
        
        /*SELECT TITLE_ID INTO TO_RETURN FROM TITLES WHERE 
            (UPPER(TITLE) = UPPER(TITLE_TO_SEARCH.TITLE))
            OR ((TITLE IS NULL) AND (TITLE_TO_SEARCH.TITLE IS NULL))
        AND 
            (PUB_DATE = TITLE_TO_SEARCH.PUB_DATE)
            OR ((PUB_DATE IS NULL) AND (TITLE_TO_SEARCH.PUB_DATE IS NULL));*/
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN TITLE_NULL THEN
            RAISE_APPLICATION_ERROR(-20003, 'TITLE CANNOT BE EMPTY');
        WHEN WRONG_AGE_LIMIT THEN
            RAISE_APPLICATION_ERROR(-20004, 'AGE LIMIT OF THE TITLE MUST BE BETWEEN 7 AND 18');
        --WHEN TOO_MANY_ROWS THEN
            
    END SEARCH_TITLE;
    
    FUNCTION SEARCH_TITLE (TITLE VARCHAR2, PUB_DATE DATE, AGE_LIMIT NUMBER, TITLE_DESCRIPTION BLOB)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_TO_SEARCH TITLE_RECORD;
    BEGIN
        TITLE_TO_SEARCH := TITLE_RECORD(TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION);
        TO_RETURN := SEARCH_TITLE(TITLE_TO_SEARCH);
        RETURN TO_RETURN;
    END SEARCH_TITLE;
    
    -- ==================================================================
    FUNCTION ADD_TITLE (TITLE_TO_ADD TITLE_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        TITLE_NULL EXCEPTION;
        WRONG_AGE_LIMIT EXCEPTION;
    BEGIN
        IF TITLE_TO_ADD.TITLE IS NULL THEN RAISE TITLE_NULL; END IF;
        
        IF TITLE_TO_ADD.AGE_LIMIT NOT BETWEEN 7 AND 18 THEN
            RAISE WRONG_AGE_LIMIT;
        END IF;
        
        INSERT INTO TITLES
        (TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION) VALUES
        (TITLE_TO_ADD.TITLE, TITLE_TO_ADD.PUB_DATE,
        TITLE_TO_ADD.AGE_LIMIT, TITLE_TO_ADD.TITLE_DESCRIPTION)
        RETURNING TITLE_ID INTO TO_RETURN;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN TITLE_NULL THEN
            RAISE_APPLICATION_ERROR(-20003, 'TITLE CANNOT BE EMPTY');
        WHEN WRONG_AGE_LIMIT THEN
            RAISE_APPLICATION_ERROR(-20004, 'AGE LIMIT OF THE TITLE MUST BE BETWEEN 7 AND 18');
    END ADD_TITLE;
    
    FUNCTION ADD_TITLE (TITLE VARCHAR2, PUB_DATE DATE, AGE_LIMIT NUMBER, TITLE_DESCRIPTION BLOB)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_TO_ADD TITLE_RECORD;
    BEGIN
        TITLE_TO_ADD := TITLE_RECORD(TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION);
        TO_RETURN := ADD_TITLE(TITLE_TO_ADD);
        RETURN TO_RETURN;
    END ADD_TITLE;
    
    -- ==================================================================
    FUNCTION PICK_TITLE (PICKED_TITLE_ID NUMBER, TITLE_TO_PICK TITLE_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        TITLE_NULL EXCEPTION;
        WRONG_AGE_LIMIT EXCEPTION;
    BEGIN
        IF TITLE_TO_PICK.TITLE IS NULL THEN RAISE TITLE_NULL; END IF;
        
        IF TITLE_TO_PICK.AGE_LIMIT NOT BETWEEN 7 AND 18 THEN
            RAISE WRONG_AGE_LIMIT;
        END IF;
        
        IF PICKED_TITLE_ID IS NULL THEN
            TO_RETURN := ADD_TITLE(TITLE_TO_PICK);
        ELSE
            TO_RETURN := PICKED_TITLE_ID;
        END IF;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN TITLE_NULL THEN
            RAISE_APPLICATION_ERROR(-20003, 'TITLE CANNOT BE EMPTY');
        WHEN WRONG_AGE_LIMIT THEN
            RAISE_APPLICATION_ERROR(-20004, 'AGE LIMIT OF THE TITLE MUST BE BETWEEN 7 AND 18');
    END PICK_TITLE;
    
    FUNCTION PICK_TITLE (PICKED_TITLE_ID NUMBER, TITLE VARCHAR2, PUB_DATE DATE, AGE_LIMIT NUMBER, TITLE_DESCRIPTION BLOB)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_TO_PICK TITLE_RECORD;
    BEGIN
        TITLE_TO_PICK := TITLE_RECORD(TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION);
        TO_RETURN := PICK_TITLE(PICKED_TITLE_ID, TITLE_TO_PICK);
        RETURN TO_RETURN;
    END PICK_TITLE;
    
    -- ==================================================================
    FUNCTION AUTHORS_TITLES_RELATION (RELATION_AUTHORS ID_ARRAY, RELATION_TITLE_ID NUMBER)
        RETURN NUMBER
    AS
        RELATIONS_CREATED NUMBER := 0;
        CHECK_VAR NUMBER;
        WRONG_TITLE_ID EXCEPTION;
        WRONG_AUTHOR_ID EXCEPTION;
    BEGIN
        SELECT COUNT(TITLE_ID) INTO CHECK_VAR FROM TITLES WHERE TITLE_ID = RELATION_TITLE_ID;
        
        IF CHECK_VAR != 1 THEN RAISE WRONG_TITLE_ID; END IF;
        
        FOR I IN 1..RELATION_AUTHORS.LAST LOOP
            SELECT COUNT(AUTHOR_ID) INTO CHECK_VAR FROM AUTHORS
            WHERE AUTHOR_ID = RELATION_AUTHORS(I);
            
            IF CHECK_VAR != 1 THEN RAISE WRONG_AUTHOR_ID; END IF;
            
            SELECT COUNT(*) INTO CHECK_VAR FROM AUTHORS_TITLES
            WHERE AUTHOR_ID = RELATION_AUTHORS(I) AND TITLE_ID = RELATION_TITLE_ID;
            IF CHECK_VAR = 0 THEN -- JEZELI NIE MA JESZCZE TEJ RELACJI, DODAJ JA
                INSERT INTO AUTHORS_TITLES (AUTHOR_ID, TITLE_ID) VALUES
                (RELATION_AUTHORS(I), RELATION_TITLE_ID);
                RELATIONS_CREATED := RELATIONS_CREATED + 1;
            END IF;
        END LOOP;
        
        RETURN RELATIONS_CREATED;
    EXCEPTION
        WHEN WRONG_TITLE_ID THEN
            RAISE_APPLICATION_ERROR(-20013, 'TITLE_ID NOT FOUND WHILE ADDING AUTHORS-TITLE RELATION');
        WHEN WRONG_AUTHOR_ID THEN
            RAISE_APPLICATION_ERROR(-20014, 'AUTHOR_ID NOT FOUND WHILE ADDING AUTHORS-TITLE RELATION');
    END AUTHORS_TITLES_RELATION;
    
    -- ==================================================================
    FUNCTION GET_LOCATION_LIST (BOOKS_AMOUNT NUMBER) 
        RETURN LOCATIONS_DICTIONARY
    AS
        ADDED_LOCATION_SPOTS LOCATION_SPOTS := LOCATION_SPOTS();
        TO_RETURN LOCATIONS_DICTIONARY := LOCATIONS_DICTIONARY();
        FREE_SPOTS_IN_LOCATION NUMBER;
        LOCATION_ID_ARRAY ID_ARRAY;
        I NUMBER := 1;
        CURRENT_LOCATION_ID NUMBER;
        BOOKS_LEFT NUMBER := BOOKS_AMOUNT;
        REQUEST_LOCK_RET_CODE INTEGER;
        RELEASE_LOCK_RET_CODE INTEGER;
        
        ZERO_BOOKS EXCEPTION;
        RUN_OUT_OF_LOCATIONS EXCEPTION;
        
        LOCK_ALREADY_RELEASED EXCEPTION;
        LOCK_REQ_PARAMETER_ERR EXCEPTION;
        LOCK_REL_PARAMETER_ERR EXCEPTION;
        LOCK_REQ_ILLEGAL_HANDLE EXCEPTION;
        LOCK_REL_ILLEGAL_HANDLE EXCEPTION;
        LOCK_DEADLOCK EXCEPTION;
    BEGIN
    
        -- WYJATEK JEZELI LICZBA DODAWANYCH KSIAZEK JEST MNIEJSZA NIZ 1
        IF BOOKS_AMOUNT < 1 THEN
            RAISE ZERO_BOOKS;
        END IF;
        
        -- SPORZADZ ARRAY WSZYSTKICH LOCATION_ID
        SELECT LOCATION_ID BULK COLLECT INTO LOCATION_ID_ARRAY FROM LOCATIONS ORDER BY CORRIDOR, RACK, SHELF;
    
        -- DOPOKI ZOSTALY KSIAZKI DO ROZMIESZCZENIA
        WHILE BOOKS_LEFT > 0 LOOP
        
            CURRENT_LOCATION_ID := LOCATION_ID_ARRAY(I);
            
            DBMS_OUTPUT.PUT_LINE('LOOP ITERATION NO. ' || I);
            
            REQUEST_LOCK_RET_CODE := LOCK_LOCATION(CURRENT_LOCATION_ID);
            
            CASE REQUEST_LOCK_RET_CODE
            
                WHEN 0 THEN -- BLOKADA UDANA
                    DBMS_OUTPUT.PUT_LINE('LOCATION_ID '||CURRENT_LOCATION_ID||' LOCKED');
                    
                    -- ILE KSIAZEK JUZ LEZY W DANEJ LOKALIZACJI
                    SELECT EMPTY_SPOTS_LEFT INTO FREE_SPOTS_IN_LOCATION FROM LOCATIONS
                    WHERE LOCATION_ID = CURRENT_LOCATION_ID;
                    
                    DBMS_OUTPUT.PUT_LINE('FREE SPOTS IN LOCATION ' || CURRENT_LOCATION_ID || ': ' ||
                        FREE_SPOTS_IN_LOCATION);
                    
                    IF FREE_SPOTS_IN_LOCATION > 0 THEN
                    
                        -- JEZELI TO OSTATNIE SZTUKI I NIE ZAJMA WSZYSTKICH MIEJSC W LOKALIZACJI
                        IF BOOKS_LEFT < FREE_SPOTS_IN_LOCATION THEN
                            FREE_SPOTS_IN_LOCATION := BOOKS_LEFT;
                        END IF;
                        
                        DBMS_OUTPUT.PUT_LINE('NUMBER OF SPOTS TO FILL IN LOCATION ' || CURRENT_LOCATION_ID || ': ' ||
                            FREE_SPOTS_IN_LOCATION);
                        
                        
                        -- ZAPISZ ILE KSIAZEK UMIESCIMY W DANEJ LOKALIZACJI
                        ADDED_LOCATION_SPOTS := LOCATION_SPOTS(CURRENT_LOCATION_ID, FREE_SPOTS_IN_LOCATION);
                        
                        -- ODEJMIJ ILOSC KSIAZEK WLASNIE ROZMIESZCZONYCH
                        BOOKS_LEFT := BOOKS_LEFT - FREE_SPOTS_IN_LOCATION;
                        DBMS_OUTPUT.PUT_LINE('BOOKS LEFT TO PLACE: ' || BOOKS_LEFT);
                        
                        -- DODAJ DO ZBIOROWEJ LISTY WSZYSTKICH LOCATION_ID W KTORYCH BEDZIEMY ROZMIESZCZAC
                        TO_RETURN.EXTEND(1);
                        TO_RETURN(TO_RETURN.LAST) := ADDED_LOCATION_SPOTS;
                        
                        
                    ELSE -- IF FREE_SPOTS_IN_LOCATION = 0 ZDEJMUJEMY LOCKA OD RAZU BO NIC TU NIE DODAJEMY
                        RELEASE_LOCK_RET_CODE := RELEASE_LOCK_LOCATION(CURRENT_LOCATION_ID);
                        CASE RELEASE_LOCK_RET_CODE
                            WHEN 0 THEN
                                DBMS_OUTPUT.PUT_LINE('LOCK ON LOCATION_ID '||CURRENT_LOCATION_ID||' RELEASED AS IT HAS NO FREE SPOTS');
                            WHEN 3 THEN
                                RAISE LOCK_REL_PARAMETER_ERR;
                            WHEN 4 THEN
                                RAISE LOCK_ALREADY_RELEASED;
                            WHEN 5 THEN
                                RAISE LOCK_REL_ILLEGAL_HANDLE;
                        END CASE;
                    END IF;
                    
                WHEN 1 THEN -- TIMEOUT
                    DBMS_OUTPUT.PUT_LINE('TIMEOUT TRYING TO LOCK LOCATION ' || TO_CHAR(LOCATION_ID_ARRAY(I)));
                WHEN 2 THEN -- DEADLOCK
                    RAISE LOCK_DEADLOCK;
                WHEN 3 THEN -- PARAMETER ERROR
                    RAISE LOCK_REQ_PARAMETER_ERR;
                WHEN 4 THEN -- LOKALIZACJA JUZ ZABLOKOWANA
                    DBMS_OUTPUT.PUT_LINE('LOCATION ' || TO_CHAR(LOCATION_ID_ARRAY(I) || ' ALREADY LOCKED'));
                WHEN 5 THEN -- ILLEGAL LOCKHANDLE
                    RAISE LOCK_REQ_ILLEGAL_HANDLE;
            
            END CASE;
            
            -- PRZEJDZ DO KOLEJNEJ LOKALIZACJI
            I := I + 1;
            
            -- WYJATEK JEZELI SKONCZYLY SIE LOKALIZACJE
            -- A NADAL NIE ROZMIESCILISMY WSZYSTKICH KSIAZEK
            IF I > LOCATION_ID_ARRAY.LAST THEN
                RAISE RUN_OUT_OF_LOCATIONS;
            END IF;
            
            DBMS_OUTPUT.PUT_LINE('');
            
        END LOOP;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN ZERO_BOOKS THEN
            RAISE_APPLICATION_ERROR(-20005, 'NUMBER OF BOOKS TO ADD MUST BE AT LEAST 1');
            
        WHEN RUN_OUT_OF_LOCATIONS THEN
            RAISE_APPLICATION_ERROR(-20006, 'NOT ENOUGH FREE SPOTS TO PUT ALL NEW BOOKS IN');
            
        WHEN LOCK_REQ_PARAMETER_ERR THEN
            RAISE_APPLICATION_ERROR(-20010, 'PARAMETER ERROR WHILE REQUESTING LOCK ON LOCATION_ID '
                || TO_CHAR(CURRENT_LOCATION_ID));
                
        WHEN LOCK_REL_PARAMETER_ERR THEN
            RAISE_APPLICATION_ERROR(-20016, 'PARAMETER ERROR WHILE RELEASING LOCK ON LOCATION_ID '
                || TO_CHAR(CURRENT_LOCATION_ID));
                
        WHEN LOCK_ALREADY_RELEASED THEN
            RAISE_APPLICATION_ERROR(-20011, 'LOCK ON LOCATION_ID ' || TO_CHAR(CURRENT_LOCATION_ID)
                || ' ALREADY RELEASED');
                
        WHEN LOCK_REQ_ILLEGAL_HANDLE THEN
            RAISE_APPLICATION_ERROR(-20012, 'ILLEGAL LOCKHANDLE WHILE REQUESTING LOCK ON LOCATION_ID '
                || TO_CHAR(CURRENT_LOCATION_ID));
                
        WHEN LOCK_REL_ILLEGAL_HANDLE THEN
            RAISE_APPLICATION_ERROR(-20017, 'ILLEGAL LOCKHANDLE WHILE RELEASING LOCK ON LOCATION_ID '
                || TO_CHAR(CURRENT_LOCATION_ID));
                
        WHEN LOCK_DEADLOCK THEN
            RAISE_APPLICATION_ERROR(-20015, 'DEADLOCK WHILE REQUESTING LOCK ON LOCATION_ID '
                || TO_CHAR(CURRENT_LOCATION_ID));
                
    END GET_LOCATION_LIST;
    
    -- ==================================================================
    FUNCTION ADD_BOOK (BOOK_TO_ADD BOOK_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        BOOK_VALUE_WRONG EXCEPTION;
        CONDITION_WRONG EXCEPTION;
        BUY_DATE_WRONG EXCEPTION;
        LOCATION_WRONG EXCEPTION;
        CHECK_VAR NUMBER;
    BEGIN
        IF NOT(BOOK_TO_ADD.BOOK_VALUE > 0) THEN RAISE BOOK_VALUE_WRONG; END IF;
        IF NOT(BOOK_TO_ADD.CONDITION BETWEEN 1 AND 5) THEN RAISE CONDITION_WRONG; END IF;
        IF NOT(BOOK_TO_ADD.BUY_DATE >= TO_DATE('2022-09-01', 'YYYY-MM-DD')) THEN RAISE BUY_DATE_WRONG; END IF;
        
        SELECT COUNT(LOCATION_ID) INTO CHECK_VAR FROM LOCATIONS
        WHERE LOCATION_ID = BOOK_TO_ADD.LOCATION_ID;
        
        IF CHECK_VAR != 1 THEN RAISE LOCATION_WRONG; END IF;
    
        INSERT INTO BOOKS (TITLE_ID, BORROW_STATE, LOCATION_ID, BOOK_VALUE, CONDITION, BUY_DATE, DELIVERY_ID)
        VALUES (BOOK_TO_ADD.TITLE_ID, 'IN STORAGE', BOOK_TO_ADD.LOCATION_ID, 
        BOOK_TO_ADD.BOOK_VALUE, BOOK_TO_ADD.CONDITION, BOOK_TO_ADD.BUY_DATE, BOOK_TO_ADD.DELIVERY_ID)
        RETURNING BOOK_ID INTO TO_RETURN;
        
        UPDATE LOCATIONS SET EMPTY_SPOTS_LEFT = EMPTY_SPOTS_LEFT - 1
        WHERE LOCATION_ID = BOOK_TO_ADD.LOCATION_ID;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN BOOK_VALUE_WRONG THEN
            RAISE_APPLICATION_ERROR(-20007, 'BOOK VALUE MUST BE POSITIVE');
        WHEN CONDITION_WRONG THEN
            RAISE_APPLICATION_ERROR(-20008, 'CONDITION MUST BE BETWEEN 1 AND 5');
        WHEN BUY_DATE_WRONG THEN
            RAISE_APPLICATION_ERROR(-20009, 'BUY DATE MUST BE LATER THAN OR EQUAL TO SEP 1, 2022');
        WHEN LOCATION_WRONG THEN
             RAISE_APPLICATION_ERROR(-20018, 'LOCATION_ID ' || TO_CHAR(BOOK_TO_ADD.LOCATION_ID) || ' NOT FOUND');
    END ADD_BOOK;
    
    FUNCTION ADD_BOOK (TITLE_ID NUMBER, LOCATION_ID NUMBER, BOOK_VALUE NUMBER, 
        CONDITION NUMBER, BUY_DATE DATE)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        BOOK_TO_ADD BOOK_RECORD;
    BEGIN
        BOOK_TO_ADD := BOOK_RECORD(TITLE_ID, LOCATION_ID, BOOK_VALUE, CONDITION,
        BUY_DATE);
        TO_RETURN := ADD_BOOK(BOOK_TO_ADD);
        RETURN TO_RETURN;
    END ADD_BOOK;
    
    -- ==================================================================
    FUNCTION ADD_BOOKS (TITLE_ID NUMBER,
        ADDED_BOOKS_LOCATIONS LOCATIONS_DICTIONARY,
        HOW_MANY_BOOKS NUMBER,
        ADDED_BOOKS_VALUE NUMBER,
        ADDED_BOOKS_CONDITION NUMBER,
        ADDED_BOOKS_BUY_DATE DATE,
        DELIVERY_ID NUMBER
    ) RETURN ID_ARRAY
    AS
        TO_RETURN ID_ARRAY := ID_ARRAY();
        CURRENT_BOOK_ID NUMBER;
        CURRENT_LOCATION_ID NUMBER := ADDED_BOOKS_LOCATIONS(1).LOCATION_ID;
        BOOKS_LEFT NUMBER := HOW_MANY_BOOKS;
        LOCATION_INDEX NUMBER := 0;
        SPOTS_LEFT NUMBER := ADDED_BOOKS_LOCATIONS(1).NUMBER_OF_EMPTY_SPOTS;
        BOOK_TO_ADD BOOK_RECORD;
        RELEASE_LOCK_LOCATION_RET_CODE INTEGER;
        PREV_LOCATION_ID NUMBER;
        
        LOCK_ALREADY_RELEASED EXCEPTION;
        LOCK_REL_PARAMETER_ERR EXCEPTION;
        LOCK_REL_ILLEGAL_HANDLE EXCEPTION;
    BEGIN
        WHILE BOOKS_LEFT > 0 LOOP

            LOCATION_INDEX := LOCATION_INDEX + 1;
            
            DBMS_OUTPUT.PUT_LINE('CURRENT LOCATION_ID: ' ||
                ADDED_BOOKS_LOCATIONS(LOCATION_INDEX).LOCATION_ID);
            DBMS_OUTPUT.PUT_LINE('');
            
            SPOTS_LEFT := ADDED_BOOKS_LOCATIONS(LOCATION_INDEX).NUMBER_OF_EMPTY_SPOTS;
        
            -- JEZELI NIE MA MIEJSCA W DANEJ LOKALIZACJI, SPROBUJ KOLEJNA
            WHILE SPOTS_LEFT > 0 AND BOOKS_LEFT > 0 LOOP
                DBMS_OUTPUT.PUT_LINE('LOCATION INDEX: ' || LOCATION_INDEX);
                DBMS_OUTPUT.PUT_LINE('SPOTS LEFT HERE: ' || SPOTS_LEFT);
                
                -- ZAPISZ OBECNE LOCATION_ID
                CURRENT_LOCATION_ID := ADDED_BOOKS_LOCATIONS(LOCATION_INDEX).LOCATION_ID;
                
                -- PRZYGOTUJ KROTKE POJEDYNCZEJ KSIAZKI DO DODANIA
                BOOK_TO_ADD := BOOK_RECORD(TITLE_ID, CURRENT_LOCATION_ID,
                ADDED_BOOKS_VALUE, ADDED_BOOKS_CONDITION, ADDED_BOOKS_BUY_DATE,
                DELIVERY_ID);
                
                -- DODAJ KROTKE POJEDYNCZEJ KSIAZKI
                CURRENT_BOOK_ID := ADD_BOOK(BOOK_TO_ADD);
                
                -- DOPISZ ID DODANEJ KSIAZKI DO LISTY ID
                TO_RETURN.EXTEND(1);
                TO_RETURN(TO_RETURN.LAST) := CURRENT_BOOK_ID;
                
                BOOKS_LEFT := BOOKS_LEFT - 1;
                SPOTS_LEFT := SPOTS_LEFT - 1;
                
                DBMS_OUTPUT.PUT_LINE('JUST ADDED BOOK ID: ' || CURRENT_BOOK_ID);
                DBMS_OUTPUT.PUT_LINE('BOOKS LEFT TO ADD: ' || BOOKS_LEFT);
                DBMS_OUTPUT.PUT_LINE('');
            END LOOP;
            
            PREV_LOCATION_ID := ADDED_BOOKS_LOCATIONS(LOCATION_INDEX).LOCATION_ID;
            
            RELEASE_LOCK_LOCATION_RET_CODE := 
                RELEASE_LOCK_LOCATION(PREV_LOCATION_ID);
                
            CASE RELEASE_LOCK_LOCATION_RET_CODE
                WHEN 0 THEN
                    DBMS_OUTPUT.PUT_LINE(' LOCK ON LOCATION_ID ' || TO_CHAR(PREV_LOCATION_ID)
                        || ' SUCCESSFULLY RELEASED');
                WHEN 3 THEN
                    RAISE LOCK_REL_PARAMETER_ERR;
                WHEN 4 THEN
                    RAISE LOCK_ALREADY_RELEASED;
                WHEN 5 THEN
                    RAISE LOCK_REL_ILLEGAL_HANDLE;
            END CASE;
            DBMS_OUTPUT.PUT_LINE('');
            
        END LOOP;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN LOCK_REL_PARAMETER_ERR THEN
            RAISE_APPLICATION_ERROR(-20016, 'PARAMETER ERROR WHILE RELEASING LOCK ON LOCATION_ID '
                || TO_CHAR(PREV_LOCATION_ID));
                
        WHEN LOCK_ALREADY_RELEASED THEN
            RAISE_APPLICATION_ERROR(-20011, 'LOCK ON LOCATION_ID ' || TO_CHAR(PREV_LOCATION_ID)
                || ' ALREADY RELEASED');
                
        WHEN LOCK_REL_ILLEGAL_HANDLE THEN
            RAISE_APPLICATION_ERROR(-20017, 'ILLEGAL LOCKHANDLE WHILE RELEASING LOCK ON LOCATION_ID '
                || TO_CHAR(PREV_LOCATION_ID));
    END ADD_BOOKS;
    
    -- ==================================================================
    FUNCTION LOCK_LOCATION (T_LOCATION_ID NUMBER, T_TIMEOUT INTEGER := 1) 
    RETURN INTEGER
    IS
        T_LOCKNAME VARCHAR2(128) := 'LOCATION_LOCK_' || TO_CHAR(T_LOCATION_ID);
        T_LOCKHANDLE VARCHAR2(128);
        WRONG_LOCATION_ID EXCEPTION;
        LOCATION_CHECK NUMBER;
    BEGIN
        SELECT COUNT(LOCATION_ID) INTO LOCATION_CHECK FROM LOCATIONS
        WHERE LOCATION_ID = T_LOCATION_ID;
        
        IF LOCATION_CHECK != 1 THEN RAISE WRONG_LOCATION_ID; END IF;
        
        DBMS_LOCK.ALLOCATE_UNIQUE(
                                  LOCKNAME => T_LOCKNAME
                                 ,LOCKHANDLE => T_LOCKHANDLE);
        
        RETURN DBMS_LOCK.REQUEST(
                                 LOCKHANDLE => T_LOCKHANDLE
                                ,TIMEOUT => T_TIMEOUT
                                ,RELEASE_ON_COMMIT => FALSE);
    EXCEPTION
        WHEN WRONG_LOCATION_ID THEN
            RAISE_APPLICATION_ERROR(-20019, 'LOCK REQUESTED ON NONEXISTENT LOCATION_ID ' 
                || TO_CHAR(T_LOCATION_ID));
    END LOCK_LOCATION;
    
    -- ==================================================================
    FUNCTION RELEASE_LOCK_LOCATION (T_LOCATION_ID NUMBER)
    RETURN INTEGER
    IS
        T_LOCKNAME VARCHAR2(128) := 'LOCATION_LOCK_' || TO_CHAR(T_LOCATION_ID);
        T_LOCKHANDLE VARCHAR2(128);
        LOCATION_CHECK NUMBER;
        WRONG_LOCATION_ID EXCEPTION;
    BEGIN
        SELECT COUNT(LOCATION_ID) INTO LOCATION_CHECK FROM LOCATIONS
        WHERE LOCATION_ID = T_LOCATION_ID;
        
        IF LOCATION_CHECK != 1 THEN RAISE WRONG_LOCATION_ID; END IF;
        
        DBMS_LOCK.ALLOCATE_UNIQUE(
                                  LOCKNAME => T_LOCKNAME
                                 ,LOCKHANDLE => T_LOCKHANDLE);
                                 
        RETURN DBMS_LOCK.RELEASE(
                                 LOCKHANDLE => T_LOCKHANDLE);
    EXCEPTION
        WHEN WRONG_LOCATION_ID THEN
            RAISE_APPLICATION_ERROR(-20020, 'LOCK REQUESTED ON NONEXISTENT LOCATION_ID ' 
                || TO_CHAR(T_LOCATION_ID));
    END RELEASE_LOCK_LOCATION;
    
    -- ==================================================================
    PROCEDURE CK_ADDRESS (T_ADDRESS_RECORD ADDRESS_RECORD)
    IS
        POSTAL_CODE_NULL EXCEPTION;
        POSTAL_CITY_NULL EXCEPTION;
        CITY_NULL EXCEPTION;
        HOUSE_NO_NULL EXCEPTION;
    BEGIN
        IF T_ADDRESS_RECORD.POSTAL_CODE IS NULL THEN RAISE POSTAL_CODE_NULL; END IF;
        IF T_ADDRESS_RECORD.POSTAL_CITY IS NULL THEN RAISE POSTAL_CITY_NULL; END IF;
        IF T_ADDRESS_RECORD.CITY IS NULL THEN RAISE CITY_NULL; END IF;
        IF T_ADDRESS_RECORD.HOUSE_NO IS NULL THEN RAISE HOUSE_NO_NULL; END IF;
    EXCEPTION
        WHEN POSTAL_CODE_NULL THEN RAISE_APPLICATION_ERROR(-20050, 'SEARCH_ADDRESS() ERROR: POSTAL CODE CANNOT BE NULL');
        WHEN POSTAL_CITY_NULL THEN RAISE_APPLICATION_ERROR(-20051, 'SEARCH_ADDRESS() ERROR: POSTAL CITY CANNOT BE NULL');
        WHEN CITY_NULL THEN RAISE_APPLICATION_ERROR(-20052, 'SEARCH_ADDRESS() ERROR: CITY CANNOT BE NULL');
        WHEN HOUSE_NO_NULL THEN RAISE_APPLICATION_ERROR(-20053, 'SEARCH_ADDRESS() ERROR: HOUSE NO. CANNOT BE NULL');
    END CK_ADDRESS;
    
    -- ==================================================================
    PROCEDURE CK_READER (T_READER_RECORD READER_RECORD)
    IS
        LAST_NAMES_NULL EXCEPTION;
        JOIN_DATE_NULL EXCEPTION;
        BIRTH_DATE_NULL EXCEPTION;
        PHONE_NULL EXCEPTION;
        EMAIL_NULL EXCEPTION;
        BIRTH_AFTER_JOIN EXCEPTION;
        JOIN_BIRTH_FUTURE EXCEPTION;
    BEGIN
        IF T_READER_RECORD.LAST_NAMES IS NULL THEN RAISE LAST_NAMES_NULL; END IF;
        IF T_READER_RECORD.JOIN_DATE IS NULL THEN RAISE JOIN_DATE_NULL; END IF;
        IF T_READER_RECORD.BIRTH_DATE IS NULL THEN RAISE BIRTH_DATE_NULL; END IF;
        IF T_READER_RECORD.PHONE IS NULL THEN RAISE PHONE_NULL; END IF;
        IF T_READER_RECORD.EMAIL IS NULL THEN RAISE EMAIL_NULL; END IF;
        IF T_READER_RECORD.JOIN_DATE < T_READER_RECORD.BIRTH_DATE THEN
            RAISE BIRTH_AFTER_JOIN; END IF;
        IF T_READER_RECORD.JOIN_DATE > SYSDATE OR T_READER_RECORD.BIRTH_DATE > SYSDATE THEN
            RAISE JOIN_BIRTH_FUTURE; END IF;
    EXCEPTION
        WHEN LAST_NAMES_NULL THEN RAISE_APPLICATION_ERROR(-20054, 'SEARCH_READER() ERROR: LAST_NAMES CANNOT BE NULL'); 
        WHEN JOIN_DATE_NULL THEN RAISE_APPLICATION_ERROR(-20055, 'SEARCH_READER() ERROR: JOIN_DATE CANNOT BE NULL'); 
        WHEN BIRTH_DATE_NULL THEN RAISE_APPLICATION_ERROR(-20056, 'SEARCH_READER() ERROR: BIRTH_DATE CANNOT BE NULL');  
        WHEN PHONE_NULL THEN RAISE_APPLICATION_ERROR(-20057, 'SEARCH_READER() ERROR: PHONE CANNOT BE NULL');
        WHEN EMAIL_NULL THEN RAISE_APPLICATION_ERROR(-20058, 'SEARCH_READER() ERROR: EMAIL CANNOT BE NULL');
        WHEN BIRTH_AFTER_JOIN THEN RAISE_APPLICATION_ERROR(-20059, 'SEARCH_READER() ERROR: BIRTH_DATE CANNOT BE LATER THAN JOIN_DATE');
        WHEN JOIN_BIRTH_FUTURE THEN RAISE_APPLICATION_ERROR(-20060, 'SEARCH_READER() ERROR: JOIN_DATE OR BIRTH_DATE CANNOT BE IN THE FUTURE');

    END CK_READER;

    -- ==================================================================
    FUNCTION SEARCH_ADDRESS (T_ADDRESS_RECORD ADDRESS_RECORD)
    RETURN NUMBER
    IS
        TO_RETURN NUMBER;
    BEGIN
        CK_ADDRESS(T_ADDRESS_RECORD);
        SELECT ADDRESS_ID INTO TO_RETURN FROM ADDRESSES
        WHERE UPPER(POSTAL_CODE) = UPPER(T_ADDRESS_RECORD.POSTAL_CODE)
        AND UPPER(POSTAL_CITY) = UPPER(T_ADDRESS_RECORD.POSTAL_CITY)
        AND UPPER(CITY) = UPPER(T_ADDRESS_RECORD.CITY)
        AND UPPER(NVL(STREET, 'EWOQIUFB')) = UPPER(NVL(T_ADDRESS_RECORD.STREET, 'EWOQIUFB'))
        AND UPPER(HOUSE_NO) = UPPER(T_ADDRESS_RECORD.HOUSE_NO)
        AND UPPER(NVL(FLAT_NO, 'EWOQIUFB')) = UPPER(NVL(T_ADDRESS_RECORD.FLAT_NO, 'EWOQIUFB'));
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN RETURN NULL;      
    END SEARCH_ADDRESS;
        
    FUNCTION SEARCH_ADDRESS (POSTAL_CODE VARCHAR2, POSTAL_CITY VARCHAR2, 
        CITY VARCHAR2, STREET VARCHAR2, HOUSE_NO VARCHAR2, FLAT_NO VARCHAR2, NOTES VARCHAR2)
    RETURN NUMBER
    IS
        T_ADDRESS_RECORD ADDRESS_RECORD;
    BEGIN
        T_ADDRESS_RECORD := ADDRESS_RECORD(POSTAL_CODE, POSTAL_CITY, CITY, STREET, HOUSE_NO, FLAT_NO, NOTES);
            
        RETURN SEARCH_ADDRESS (T_ADDRESS_RECORD);
    END SEARCH_ADDRESS;
    
    -- ==================================================================
    FUNCTION ADD_ADDRESS (T_ADDRESS_RECORD ADDRESS_RECORD)
    RETURN NUMBER
    IS
        TO_RETURN NUMBER;
    BEGIN
        CK_ADDRESS(T_ADDRESS_RECORD);

        INSERT INTO ADDRESSES (POSTAL_CODE, POSTAL_CITY, CITY, STREET, HOUSE_NO, FLAT_NO, NOTES) 
        VALUES (T_ADDRESS_RECORD.POSTAL_CODE, T_ADDRESS_RECORD.POSTAL_CITY, T_ADDRESS_RECORD.CITY,
        T_ADDRESS_RECORD.STREET, T_ADDRESS_RECORD.HOUSE_NO, T_ADDRESS_RECORD.FLAT_NO,
        T_ADDRESS_RECORD.NOTES) RETURNING ADDRESS_ID INTO TO_RETURN;
        
        RETURN TO_RETURN;
    END ADD_ADDRESS;
        
    FUNCTION ADD_ADDRESS (POSTAL_CODE VARCHAR2, POSTAL_CITY VARCHAR2, 
        CITY VARCHAR2, STREET VARCHAR2, HOUSE_NO VARCHAR2, FLAT_NO VARCHAR2, NOTES VARCHAR2)
    RETURN NUMBER
    IS
        T_ADDRESS_RECORD ADDRESS_RECORD;
    BEGIN
        T_ADDRESS_RECORD := ADDRESS_RECORD(POSTAL_CODE, POSTAL_CITY, CITY, STREET, HOUSE_NO, FLAT_NO, NOTES);
        
        RETURN ADD_ADDRESS (T_ADDRESS_RECORD);
    END ADD_ADDRESS;
        
    -- ==================================================================
    FUNCTION PICK_ADDRESS (T_ADDRESS_ID NUMBER, T_ADDRESS_RECORD ADDRESS_RECORD)
    RETURN NUMBER
    IS
    BEGIN
        CK_ADDRESS(T_ADDRESS_RECORD);

        IF T_ADDRESS_ID IS NULL THEN
            RETURN ADD_ADDRESS(T_ADDRESS_RECORD);
        END IF;
        RETURN T_ADDRESS_ID;
    END PICK_ADDRESS;
        
    FUNCTION PICK_ADDRESS (T_ADDRESS_ID NUMBER, POSTAL_CODE VARCHAR2, POSTAL_CITY VARCHAR2, 
        CITY VARCHAR2, STREET VARCHAR2, HOUSE_NO VARCHAR2, FLAT_NO VARCHAR2, NOTES VARCHAR2)
    RETURN NUMBER
    IS
        T_ADDRESS_RECORD ADDRESS_RECORD;
    BEGIN
        T_ADDRESS_RECORD := ADDRESS_RECORD(POSTAL_CODE, POSTAL_CITY, CITY, STREET, HOUSE_NO, FLAT_NO, NOTES);
        
        RETURN PICK_ADDRESS (T_ADDRESS_ID, T_ADDRESS_RECORD);
    END PICK_ADDRESS;
    
    -- ==================================================================
    FUNCTION SEARCH_READER (T_READER_RECORD READER_RECORD)
    RETURN NUMBER
    IS
        TO_RETURN NUMBER;
    BEGIN
        CK_READER(T_READER_RECORD);
    
        SELECT READER_ID INTO TO_RETURN FROM READERS
        WHERE UPPER(NVL(FIRST_NAMES, 'EWOQIUFB')) = UPPER(NVL(T_READER_RECORD.FIRST_NAMES, 'EWOQIUFB'))
        AND UPPER(LAST_NAMES) = UPPER(T_READER_RECORD.LAST_NAMES)
        AND JOIN_DATE = T_READER_RECORD.JOIN_DATE
        AND BIRTH_DATE = T_READER_RECORD.BIRTH_DATE
        AND UPPER(PHONE) = UPPER(T_READER_RECORD.PHONE)
        AND UPPER(EMAIL) = UPPER(T_READER_RECORD.EMAIL)
        AND UPPER(NVL(PESEL, 'EWOQIUFB')) = UPPER(NVL(T_READER_RECORD.PESEL, 'EWOQIUFB'));
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN RETURN NULL;
    END SEARCH_READER;
    
    FUNCTION SEARCH_READER (FIRST_NAMES VARCHAR2, LAST_NAMES VARCHAR2, 
        JOIN_DATE DATE, BIRTH_DATE DATE, PHONE VARCHAR2, EMAIL VARCHAR2, PESEL VARCHAR2,
        DEFAULT_ADDRESS NUMBER)
    RETURN NUMBER
    IS
        T_READER_RECORD READER_RECORD;
    BEGIN
        T_READER_RECORD := READER_RECORD(FIRST_NAMES, LAST_NAMES, JOIN_DATE,
            BIRTH_DATE, PHONE, EMAIL, PESEL, DEFAULT_ADDRESS);
        
        RETURN SEARCH_READER (T_READER_RECORD);
    END SEARCH_READER;
    
    -- ==================================================================
    FUNCTION ADD_READER (T_READER_RECORD READER_RECORD)
    RETURN NUMBER
    IS
        TO_RETURN NUMBER;
    BEGIN
        CK_READER(T_READER_RECORD);        
        INSERT INTO READERS (FIRST_NAMES, LAST_NAMES, JOIN_DATE, BIRTH_DATE, PHONE, EMAIL, PESEL, DEFAULT_ADDRESS)
        VALUES (T_READER_RECORD.FIRST_NAMES, T_READER_RECORD.LAST_NAMES, T_READER_RECORD.JOIN_DATE, 
            T_READER_RECORD.BIRTH_DATE, T_READER_RECORD.PHONE, T_READER_RECORD.EMAIL, T_READER_RECORD.PESEL,
            T_READER_RECORD.DEFAULT_ADDRESS) RETURNING READER_ID INTO TO_RETURN;
            
        RETURN TO_RETURN;
    END ADD_READER;
    
    FUNCTION ADD_READER (FIRST_NAMES VARCHAR2, LAST_NAMES VARCHAR2, 
        JOIN_DATE DATE, BIRTH_DATE DATE, PHONE VARCHAR2, EMAIL VARCHAR2, PESEL VARCHAR2,
        DEFAULT_ADDRESS NUMBER)
    RETURN NUMBER
    IS
        T_READER_RECORD READER_RECORD;
    BEGIN
        T_READER_RECORD := READER_RECORD(FIRST_NAMES, LAST_NAMES, JOIN_DATE, BIRTH_DATE,
            PHONE, EMAIL, PESEL, DEFAULT_ADDRESS);
            
        RETURN ADD_READER (T_READER_RECORD);
    END ADD_READER;
    
    -- ==================================================================
    FUNCTION PICK_READER (T_READER_ID NUMBER, T_READER_RECORD READER_RECORD)
    RETURN NUMBER
    IS
    BEGIN
        CK_READER(T_READER_RECORD);        
        IF T_READER_ID IS NULL THEN 
            RETURN ADD_READER (T_READER_RECORD);
        END IF;
        RETURN T_READER_ID;
    END PICK_READER;
        
    FUNCTION PICK_READER (T_READER_ID NUMBER, FIRST_NAMES VARCHAR2, LAST_NAMES VARCHAR2, 
        JOIN_DATE DATE, BIRTH_DATE DATE, PHONE VARCHAR2, EMAIL VARCHAR2, PESEL VARCHAR2,
        DEFAULT_ADDRESS NUMBER)
    RETURN NUMBER
    IS
        T_READER_RECORD READER_RECORD;
    BEGIN
        T_READER_RECORD := READER_RECORD(FIRST_NAMES, LAST_NAMES, JOIN_DATE, BIRTH_DATE,
            PHONE, EMAIL, PESEL, DEFAULT_ADDRESS);
            
        RETURN PICK_READER (T_READER_ID, T_READER_RECORD);
    END PICK_READER;
    
BEGIN
    DBMS_OUTPUT.ENABLE(buffer_size => NULL);
END RENTAL;
/