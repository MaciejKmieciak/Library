CREATE OR REPLACE PACKAGE BODY RENTAL AS

    -- ==================================================================
    FUNCTION DELIVERY (T_DELIVERY_DICTIONARY DELIVERY_DICTIONARY)
        RETURN ID_ARRAY
    AS
        DELIVERY_PART_ID_ARRAY ID_ARRAY;
        TOTAL_ID_ARRAY ID_ARRAY;
        I NUMBER := 1;
        
        T_SQLCODE NUMBER;
        T_ERRMSG VARCHAR2(32000);
    BEGIN
        SET TRANSACTION READ ONLY NAME 'DELIVERY_TR';
        TOTAL_ID_ARRAY := ID_ARRAY();
        WHILE I <= T_DELIVERY_DICTIONARY.LAST LOOP
            SAVEPOINT T_SAVEPOINT;
            DELIVERY_PART_ID_ARRAY := DELIVERY(T_DELIVERY_DICTIONARY(I));
            TOTAL_ID_ARRAY := 
                TOTAL_ID_ARRAY MULTISET UNION DELIVERY_PART_ID_ARRAY;
            I := I + 1;
        END LOOP;
        COMMIT;
        RETURN TOTAL_ID_ARRAY;
    EXCEPTION
        WHEN OTHERS THEN
            T_SQLCODE := SQLCODE;
            T_ERRMSG := SQLERRM;
            DBMS_OUTPUT.PUT_LINE('WHEN OTHERS HAPPEND FOR ' || T_ERRMSG);
            IF T_SQLCODE BETWEEN -20020 AND -20000 THEN
                DBMS_OUTPUT.PUT_LINE('CUSTOM ERROR HAPPENED');
                I := I + 1;
                IF I <= T_DELIVERY_DICTIONARY.LAST THEN
                    DBMS_OUTPUT.PUT_LINE('THIS IS NOT THE LAST DELIVERY_PART');
                    DBMS_OUTPUT.PUT_LINE('ROLLING BACK TO SAVEPOINT');
                    ROLLBACK TO T_SAVEPOINT;
                ELSE
                    DBMS_OUTPUT.PUT_LINE('THIS IS THE LAST DELIVERY_PART');
                    RAISE_APPLICATION_ERROR(T_SQLCODE, T_ERRMSG);
                END IF;
            ELSE
                DBMS_OUTPUT.PUT_LINE('SOME OTHER ERROR HAPPENED');
                RAISE_APPLICATION_ERROR(T_SQLCODE, T_ERRMSG);
            END IF;
    END DELIVERY;
    
    FUNCTION DELIVERY (T_DELIVERY_PART DELIVERY_PART)
        RETURN ID_ARRAY
    AS
        T_AUTHOR_ID_ARRAY ID_ARRAY := ID_ARRAY();
        T_TITLE_ID NUMBER;
        T_LOCATIONS_DICTIONARY LOCATIONS_DICTIONARY;
        T_BOOK_ID_ARRAY ID_ARRAY := ID_ARRAY();
        T_BUY_DATE DATE;
        
        RELATIONS_CREATED NUMBER;
    BEGIN
        FOR I IN 1..T_DELIVERY_PART.T_AUTHORS.LAST LOOP
            T_AUTHOR_ID_ARRAY.EXTEND(1);
            T_AUTHOR_ID_ARRAY(I) := PICK_AUTHOR(
                                                SEARCH_AUTHOR(T_DELIVERY_PART.T_AUTHORS(I))
                                               ,T_DELIVERY_PART.T_AUTHORS(I));
        END LOOP;
        
        T_TITLE_ID := PICK_TITLE(
                                 SEARCH_TITLE(T_DELIVERY_PART.T_TITLE)
                                ,T_DELIVERY_PART.T_TITLE);
                                
        RELATIONS_CREATED := AUTHORS_TITLES_RELATION(
                                                     T_AUTHOR_ID_ARRAY
                                                    ,T_TITLE_ID);
        
        T_LOCATIONS_DICTIONARY := GET_LOCATION_LIST(T_DELIVERY_PART.T_AMOUNT);
        
        DBMS_OUTPUT.PUT_LINE('DICTIONARY OF LOCATIONS RETURNED: ');
        FOR I IN 1..T_LOCATIONS_DICTIONARY.LAST LOOP
            DBMS_OUTPUT.PUT_LINE(T_LOCATIONS_DICTIONARY(I).LOCATION_ID || ': ' ||
                T_LOCATIONS_DICTIONARY(I).NUMBER_OF_EMPTY_SPOTS);
        END LOOP;
        DBMS_OUTPUT.PUT_LINE('');
        
        IF T_DELIVERY_PART.T_ADDED_BOOKS_BUY_DATE IS NULL THEN
            T_BUY_DATE := SYSDATE;
        ELSE
            T_BUY_DATE := T_DELIVERY_PART.T_ADDED_BOOKS_BUY_DATE;
        END IF;
        
        T_BOOK_ID_ARRAY := ADD_BOOKS(
                                     T_TITLE_ID
                                    ,T_LOCATIONS_DICTIONARY
                                    ,T_DELIVERY_PART.T_AMOUNT
                                    ,T_DELIVERY_PART.T_ADDED_BOOKS_VALUE
                                    ,T_DELIVERY_PART.T_ADDED_BOOKS_CONDITION
                                    ,T_BUY_DATE);
                                    
        RETURN T_BOOK_ID_ARRAY;
    END DELIVERY;
    
    -- ==================================================================
    PROCEDURE INITIATE_LOCATIONS AS
    BEGIN
        EXECUTE IMMEDIATE 'TRUNCATE TABLE LOCATIONS';
        FOR I IN 1..LOCATIONS_CORRIDOR_NUMBER LOOP
            FOR J IN 1..LOCATIONS_RACK_NUMBER LOOP
                FOR K IN 1..LOCATIONS_SHELF_NUMBER LOOP
                    INSERT INTO LOCATIONS (CORRIDOR, RACK, SHELF) VALUES (I, J, K);
                END LOOP;
            END LOOP;
        END LOOP;
    END INITIATE_LOCATIONS;
    
    -- ==================================================================
    FUNCTION SEARCH_AUTHOR (AUTHOR_TO_SEARCH AUTHOR_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        LAST_NAME_NULL EXCEPTION;
        BIRTH_AFTER_DEATH EXCEPTION;
        BIRTH_DEATH_FUTURE EXCEPTION;
    BEGIN
        IF AUTHOR_TO_SEARCH.LAST_NAME IS NULL THEN RAISE LAST_NAME_NULL; END IF;
        
        IF AUTHOR_TO_SEARCH.BIRTH_DATE >= AUTHOR_TO_SEARCH.DEATH_DATE THEN
            RAISE BIRTH_AFTER_DEATH;
        END IF;
        
        IF AUTHOR_TO_SEARCH.BIRTH_DATE > SYSDATE 
        OR AUTHOR_TO_SEARCH.DEATH_DATE > SYSDATE THEN
            RAISE BIRTH_DEATH_FUTURE;
        END IF;
        
        SELECT AUTHOR_ID INTO TO_RETURN FROM AUTHORS WHERE 
            (UPPER(NVL(FIRST_NAME, '9438H45TG45')) = UPPER(NVL(AUTHOR_TO_SEARCH.FIRST_NAME, '9438H45TG45')))
        AND 
            (UPPER(LAST_NAME) = UPPER(AUTHOR_TO_SEARCH.LAST_NAME))
        AND 
            (NVL(BIRTH_DATE, SYSDATE) = NVL(AUTHOR_TO_SEARCH.BIRTH_DATE, SYSDATE))
        AND 
            (NVL(DEATH_DATE, SYSDATE) = NVL(AUTHOR_TO_SEARCH.DEATH_DATE, SYSDATE));
        
        /*SELECT AUTHOR_ID INTO TO_RETURN FROM AUTHORS WHERE 
            (UPPER(FIRST_NAME) = UPPER(AUTHOR_TO_SEARCH.FIRST_NAME)
            OR ((FIRST_NAME IS NULL) AND (AUTHOR_TO_SEARCH.FIRST_NAME IS NULL)))
        AND 
            (UPPER(LAST_NAME) = UPPER(AUTHOR_TO_SEARCH.LAST_NAME)
            OR ((LAST_NAME IS NULL) AND (AUTHOR_TO_SEARCH.LAST_NAME IS NULL)))
        AND 
            (BIRTH_DATE = AUTHOR_TO_SEARCH.BIRTH_DATE
            OR ((BIRTH_DATE IS NULL) AND (AUTHOR_TO_SEARCH.BIRTH_DATE IS NULL)))
        AND 
            (DEATH_DATE = AUTHOR_TO_SEARCH.DEATH_DATE
            OR ((DEATH_DATE IS NULL) AND (AUTHOR_TO_SEARCH.DEATH_DATE IS NULL)));*/
            
        RETURN TO_RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN LAST_NAME_NULL THEN
            RAISE_APPLICATION_ERROR(-20000, 'LAST NAME OF THE AUTHOR CANNOT BE NULL');
        WHEN BIRTH_AFTER_DEATH THEN
            RAISE_APPLICATION_ERROR(-20001, 'BIRTH DATE OF THE AUTHOR CANNOT BE LATER OR EQUAL TO THEIR DEATH DATE');
        WHEN BIRTH_DEATH_FUTURE THEN
            RAISE_APPLICATION_ERROR(-20002, 'BIRTH DATE OR DEATH DATE OF THE AUTHOR IS LATER THAN PRESENT');
        --WHEN TOO_MANY_ROWS THEN
            
    END SEARCH_AUTHOR;
    
    FUNCTION SEARCH_AUTHOR (FIRST_NAME VARCHAR2, LAST_NAME VARCHAR2,
        BIRTH_DATE DATE, DEATH_DATE DATE)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        AUTHOR_TO_SEARCH AUTHOR_RECORD;
    BEGIN
        AUTHOR_TO_SEARCH := AUTHOR_RECORD(FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE);
        TO_RETURN := SEARCH_AUTHOR(AUTHOR_TO_SEARCH);
        RETURN TO_RETURN;
    END SEARCH_AUTHOR;
    
    -- ==================================================================
    FUNCTION ADD_AUTHOR (AUTHOR_TO_ADD AUTHOR_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        LAST_NAME_NULL EXCEPTION;
        BIRTH_AFTER_DEATH EXCEPTION;
        BIRTH_DEATH_FUTURE EXCEPTION;
    BEGIN
        IF AUTHOR_TO_ADD.LAST_NAME IS NULL THEN RAISE LAST_NAME_NULL; END IF;
        
        IF AUTHOR_TO_ADD.BIRTH_DATE >= AUTHOR_TO_ADD.DEATH_DATE THEN
            RAISE BIRTH_AFTER_DEATH;
        END IF;
        
        IF AUTHOR_TO_ADD.BIRTH_DATE > SYSDATE 
        OR AUTHOR_TO_ADD.DEATH_DATE > SYSDATE THEN
            RAISE BIRTH_DEATH_FUTURE;
        END IF;
        
        INSERT INTO AUTHORS 
        (FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE) VALUES
        (AUTHOR_TO_ADD.FIRST_NAME, AUTHOR_TO_ADD.LAST_NAME,
        AUTHOR_TO_ADD.BIRTH_DATE, AUTHOR_TO_ADD.DEATH_DATE)
        RETURNING AUTHOR_ID INTO TO_RETURN;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN LAST_NAME_NULL THEN
            RAISE_APPLICATION_ERROR(-20000, 'LAST NAME OF THE AUTHOR CANNOT BE NULL');
        WHEN BIRTH_AFTER_DEATH THEN
            RAISE_APPLICATION_ERROR(-20001, 'BIRTH DATE OF THE AUTHOR CANNOT BE LATER OR EQUAL TO THEIR DEATH DATE');
        WHEN BIRTH_DEATH_FUTURE THEN
            RAISE_APPLICATION_ERROR(-20002, 'BIRTH DATE OR DEATH DATE OF THE AUTHOR IS LATER THAN PRESENT');
    END;
    
    FUNCTION ADD_AUTHOR (FIRST_NAME VARCHAR2, LAST_NAME VARCHAR2, BIRTH_DATE DATE, DEATH_DATE DATE) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        AUTHOR_TO_ADD AUTHOR_RECORD;
    BEGIN
        AUTHOR_TO_ADD := AUTHOR_RECORD(FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE);
        TO_RETURN := ADD_AUTHOR(AUTHOR_TO_ADD);
        RETURN TO_RETURN;
    END ADD_AUTHOR;
    
    -- ==================================================================
    FUNCTION PICK_AUTHOR (PICKED_AUTHOR_ID NUMBER, AUTHOR_TO_PICK AUTHOR_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        LAST_NAME_NULL EXCEPTION;
        BIRTH_AFTER_DEATH EXCEPTION;
        BIRTH_DEATH_FUTURE EXCEPTION;
    BEGIN
        IF AUTHOR_TO_PICK.LAST_NAME IS NULL THEN RAISE LAST_NAME_NULL; END IF;
        
        IF AUTHOR_TO_PICK.BIRTH_DATE >= AUTHOR_TO_PICK.DEATH_DATE THEN
            RAISE BIRTH_AFTER_DEATH;
        END IF;
        
        IF AUTHOR_TO_PICK.BIRTH_DATE > SYSDATE 
        OR AUTHOR_TO_PICK.DEATH_DATE > SYSDATE THEN
            RAISE BIRTH_DEATH_FUTURE;
        END IF;
        
        IF PICKED_AUTHOR_ID IS NULL THEN
            TO_RETURN := ADD_AUTHOR(AUTHOR_TO_PICK);
        ELSE
            TO_RETURN := PICKED_AUTHOR_ID;
        END IF;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN LAST_NAME_NULL THEN
            RAISE_APPLICATION_ERROR(-20000, 'LAST NAME OF THE AUTHOR CANNOT BE EMPTY');
        WHEN BIRTH_AFTER_DEATH THEN
            RAISE_APPLICATION_ERROR(-20001, 'BIRTH DATE OF THE AUTHOR CANNOT BE LATER OR EQUAL TO THEIR DEATH DATE');
        WHEN BIRTH_DEATH_FUTURE THEN
            RAISE_APPLICATION_ERROR(-20002, 'BIRTH DATE OR DEATH DATE OF THE AUTHOR IS LATER THAN PRESENT');
    END PICK_AUTHOR;
    
    FUNCTION PICK_AUTHOR (PICKED_AUTHOR_ID NUMBER, FIRST_NAME VARCHAR2, LAST_NAME VARCHAR2, BIRTH_DATE DATE, DEATH_DATE DATE)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        AUTHOR_TO_PICK AUTHOR_RECORD;
    BEGIN
        AUTHOR_TO_PICK := AUTHOR_RECORD(FIRST_NAME, LAST_NAME, BIRTH_DATE, DEATH_DATE);
        TO_RETURN := PICK_AUTHOR(PICKED_AUTHOR_ID, AUTHOR_TO_PICK);
        RETURN TO_RETURN;
    END PICK_AUTHOR;
    
    -- ==================================================================
    FUNCTION SEARCH_TITLE (TITLE_TO_SEARCH TITLE_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_NULL EXCEPTION;
        WRONG_AGE_LIMIT EXCEPTION;
    BEGIN
        IF TITLE_TO_SEARCH.TITLE IS NULL THEN RAISE TITLE_NULL; END IF;
        
        IF TITLE_TO_SEARCH.AGE_LIMIT NOT BETWEEN 7 AND 18 THEN
            RAISE WRONG_AGE_LIMIT;
        END IF;
        
        SELECT TITLE_ID INTO TO_RETURN FROM TITLES WHERE 
            (UPPER(TITLE) = UPPER(TITLE_TO_SEARCH.TITLE))
        AND
            (NVL(PUB_DATE, SYSDATE) = NVL(TITLE_TO_SEARCH.PUB_DATE, SYSDATE));
        
        /*SELECT TITLE_ID INTO TO_RETURN FROM TITLES WHERE 
            (UPPER(TITLE) = UPPER(TITLE_TO_SEARCH.TITLE))
            OR ((TITLE IS NULL) AND (TITLE_TO_SEARCH.TITLE IS NULL))
        AND 
            (PUB_DATE = TITLE_TO_SEARCH.PUB_DATE)
            OR ((PUB_DATE IS NULL) AND (TITLE_TO_SEARCH.PUB_DATE IS NULL));*/
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN TITLE_NULL THEN
            RAISE_APPLICATION_ERROR(-20003, 'TITLE CANNOT BE EMPTY');
        WHEN WRONG_AGE_LIMIT THEN
            RAISE_APPLICATION_ERROR(-20004, 'AGE LIMIT OF THE TITLE MUST BE BETWEEN 7 AND 18');
        --WHEN TOO_MANY_ROWS THEN
            
    END SEARCH_TITLE;
    
    FUNCTION SEARCH_TITLE (TITLE VARCHAR2, PUB_DATE DATE, AGE_LIMIT NUMBER, TITLE_DESCRIPTION BLOB)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_TO_SEARCH TITLE_RECORD;
    BEGIN
        TITLE_TO_SEARCH := TITLE_RECORD(TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION);
        TO_RETURN := SEARCH_TITLE(TITLE_TO_SEARCH);
        RETURN TO_RETURN;
    END SEARCH_TITLE;
    
    -- ==================================================================
    FUNCTION ADD_TITLE (TITLE_TO_ADD TITLE_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        TITLE_NULL EXCEPTION;
        WRONG_AGE_LIMIT EXCEPTION;
    BEGIN
        IF TITLE_TO_ADD.TITLE IS NULL THEN RAISE TITLE_NULL; END IF;
        
        IF TITLE_TO_ADD.AGE_LIMIT NOT BETWEEN 7 AND 18 THEN
            RAISE WRONG_AGE_LIMIT;
        END IF;
        
        INSERT INTO TITLES
        (TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION) VALUES
        (TITLE_TO_ADD.TITLE, TITLE_TO_ADD.PUB_DATE,
        TITLE_TO_ADD.AGE_LIMIT, TITLE_TO_ADD.TITLE_DESCRIPTION)
        RETURNING TITLE_ID INTO TO_RETURN;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN TITLE_NULL THEN
            RAISE_APPLICATION_ERROR(-20003, 'TITLE CANNOT BE EMPTY');
        WHEN WRONG_AGE_LIMIT THEN
            RAISE_APPLICATION_ERROR(-20004, 'AGE LIMIT OF THE TITLE MUST BE BETWEEN 7 AND 18');
    END ADD_TITLE;
    
    FUNCTION ADD_TITLE (TITLE VARCHAR2, PUB_DATE DATE, AGE_LIMIT NUMBER, TITLE_DESCRIPTION BLOB)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_TO_ADD TITLE_RECORD;
    BEGIN
        TITLE_TO_ADD := TITLE_RECORD(TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION);
        TO_RETURN := ADD_TITLE(TITLE_TO_ADD);
        RETURN TO_RETURN;
    END ADD_TITLE;
    
    -- ==================================================================
    FUNCTION PICK_TITLE (PICKED_TITLE_ID NUMBER, TITLE_TO_PICK TITLE_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER(10);
        TITLE_NULL EXCEPTION;
        WRONG_AGE_LIMIT EXCEPTION;
    BEGIN
        IF TITLE_TO_PICK.TITLE IS NULL THEN RAISE TITLE_NULL; END IF;
        
        IF TITLE_TO_PICK.AGE_LIMIT NOT BETWEEN 7 AND 18 THEN
            RAISE WRONG_AGE_LIMIT;
        END IF;
        
        IF PICKED_TITLE_ID IS NULL THEN
            TO_RETURN := ADD_TITLE(TITLE_TO_PICK);
        ELSE
            TO_RETURN := PICKED_TITLE_ID;
        END IF;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN TITLE_NULL THEN
            RAISE_APPLICATION_ERROR(-20003, 'TITLE CANNOT BE EMPTY');
        WHEN WRONG_AGE_LIMIT THEN
            RAISE_APPLICATION_ERROR(-20004, 'AGE LIMIT OF THE TITLE MUST BE BETWEEN 7 AND 18');
    END PICK_TITLE;
    
    FUNCTION PICK_TITLE (PICKED_TITLE_ID NUMBER, TITLE VARCHAR2, PUB_DATE DATE, AGE_LIMIT NUMBER, TITLE_DESCRIPTION BLOB)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        TITLE_TO_PICK TITLE_RECORD;
    BEGIN
        TITLE_TO_PICK := TITLE_RECORD(TITLE, PUB_DATE, AGE_LIMIT, TITLE_DESCRIPTION);
        TO_RETURN := PICK_TITLE(PICKED_TITLE_ID, TITLE_TO_PICK);
        RETURN TO_RETURN;
    END PICK_TITLE;
    
    -- ==================================================================
    FUNCTION AUTHORS_TITLES_RELATION (RELATION_AUTHORS ID_ARRAY, RELATION_TITLE_ID NUMBER)
        RETURN NUMBER
    AS
        RELATIONS_CREATED NUMBER := 0;
        CHECK_VAR NUMBER;
        WRONG_TITLE_ID EXCEPTION;
        WRONG_AUTHOR_ID EXCEPTION;
    BEGIN
        SELECT COUNT(TITLE_ID) INTO CHECK_VAR FROM TITLES WHERE TITLE_ID = RELATION_TITLE_ID;
        
        IF CHECK_VAR != 1 THEN RAISE WRONG_TITLE_ID; END IF;
        
        FOR I IN 1..RELATION_AUTHORS.LAST LOOP
            SELECT COUNT(AUTHOR_ID) INTO CHECK_VAR FROM AUTHORS
            WHERE AUTHOR_ID = RELATION_AUTHORS(I);
            
            IF CHECK_VAR != 1 THEN RAISE WRONG_AUTHOR_ID; END IF;
            
            SELECT COUNT(*) INTO CHECK_VAR FROM AUTHORS_TITLES
            WHERE AUTHOR_ID = RELATION_AUTHORS(I) AND TITLE_ID = RELATION_TITLE_ID;
            IF CHECK_VAR = 0 THEN -- JEZELI NIE MA JESZCZE TEJ RELACJI, DODAJ JA
                INSERT INTO AUTHORS_TITLES (AUTHOR_ID, TITLE_ID) VALUES
                (RELATION_AUTHORS(I), RELATION_TITLE_ID);
                RELATIONS_CREATED := RELATIONS_CREATED + 1;
            END IF;
        END LOOP;
        
        RETURN RELATIONS_CREATED;
    EXCEPTION
        WHEN WRONG_TITLE_ID THEN
            RAISE_APPLICATION_ERROR(-20013, 'TITLE_ID NOT FOUND WHILE ADDING AUTHORS-TITLE RELATION');
        WHEN WRONG_AUTHOR_ID THEN
            RAISE_APPLICATION_ERROR(-20014, 'AUTHOR_ID NOT FOUND WHILE ADDING AUTHORS-TITLE RELATION');
    END AUTHORS_TITLES_RELATION;
    
    -- ==================================================================
    FUNCTION GET_LOCATION_LIST (BOOKS_AMOUNT NUMBER) 
        RETURN LOCATIONS_DICTIONARY
    AS
        ADDED_LOCATION_SPOTS LOCATION_SPOTS := LOCATION_SPOTS();
        TO_RETURN LOCATIONS_DICTIONARY := LOCATIONS_DICTIONARY();
        FREE_SPOTS_IN_LOCATION NUMBER;
        LOCATION_ID_ARRAY ID_ARRAY;
        I NUMBER := 1;
        CURRENT_LOCATION_ID NUMBER;
        BOOKS_LEFT NUMBER := BOOKS_AMOUNT;
        REQUEST_LOCK_RET_CODE INTEGER;
        RELEASE_LOCK_RET_CODE INTEGER;
        
        ZERO_BOOKS EXCEPTION;
        RUN_OUT_OF_LOCATIONS EXCEPTION;
        
        LOCK_ALREADY_RELEASED EXCEPTION;
        LOCK_REQ_PARAMETER_ERR EXCEPTION;
        LOCK_REL_PARAMETER_ERR EXCEPTION;
        LOCK_REQ_ILLEGAL_HANDLE EXCEPTION;
        LOCK_REL_ILLEGAL_HANDLE EXCEPTION;
        LOCK_DEADLOCK EXCEPTION;
    BEGIN
    
        -- WYJATEK JEZELI LICZBA DODAWANYCH KSIAZEK JEST MNIEJSZA NIZ 1
        IF BOOKS_AMOUNT < 1 THEN
            RAISE ZERO_BOOKS;
        END IF;
        
        -- SPORZADZ ARRAY WSZYSTKICH LOCATION_ID
        SELECT LOCATION_ID BULK COLLECT INTO LOCATION_ID_ARRAY FROM LOCATIONS ORDER BY CORRIDOR, RACK, SHELF;
    
        -- DOPOKI ZOSTALY KSIAZKI DO ROZMIESZCZENIA
        WHILE BOOKS_LEFT > 0 LOOP
        
            CURRENT_LOCATION_ID := LOCATION_ID_ARRAY(I);
            
            DBMS_OUTPUT.PUT_LINE('LOOP ITERATION NO. ' || I);
            
            REQUEST_LOCK_RET_CODE := LOCK_LOCATION(CURRENT_LOCATION_ID);
            
            CASE REQUEST_LOCK_RET_CODE
            
                WHEN 0 THEN -- BLOKADA UDANA
                    DBMS_OUTPUT.PUT_LINE('LOCATION_ID '||CURRENT_LOCATION_ID||' LOCKED');
                    
                    -- ILE KSIAZEK JUZ LEZY W DANEJ LOKALIZACJI
                    SELECT EMPTY_SPOTS_LEFT INTO FREE_SPOTS_IN_LOCATION FROM LOCATIONS
                    WHERE LOCATION_ID = CURRENT_LOCATION_ID;
                    
                    DBMS_OUTPUT.PUT_LINE('FREE SPOTS IN LOCATION ' || CURRENT_LOCATION_ID || ': ' ||
                        FREE_SPOTS_IN_LOCATION);
                    
                    IF FREE_SPOTS_IN_LOCATION > 0 THEN
                    
                        -- JEZELI TO OSTATNIE SZTUKI I NIE ZAJMA WSZYSTKICH MIEJSC W LOKALIZACJI
                        IF BOOKS_LEFT < FREE_SPOTS_IN_LOCATION THEN
                            FREE_SPOTS_IN_LOCATION := BOOKS_LEFT;
                        END IF;
                        
                        DBMS_OUTPUT.PUT_LINE('NUMBER OF SPOTS TO FILL IN LOCATION ' || CURRENT_LOCATION_ID || ': ' ||
                            FREE_SPOTS_IN_LOCATION);
                        
                        
                        -- ZAPISZ ILE KSIAZEK UMIESCIMY W DANEJ LOKALIZACJI
                        ADDED_LOCATION_SPOTS := LOCATION_SPOTS(CURRENT_LOCATION_ID, FREE_SPOTS_IN_LOCATION);
                        
                        -- ODEJMIJ ILOSC KSIAZEK WLASNIE ROZMIESZCZONYCH
                        BOOKS_LEFT := BOOKS_LEFT - FREE_SPOTS_IN_LOCATION;
                        DBMS_OUTPUT.PUT_LINE('BOOKS LEFT TO PLACE: ' || BOOKS_LEFT);
                        
                        -- DODAJ DO ZBIOROWEJ LISTY WSZYSTKICH LOCATION_ID W KTORYCH BEDZIEMY ROZMIESZCZAC
                        TO_RETURN.EXTEND(1);
                        TO_RETURN(TO_RETURN.LAST) := ADDED_LOCATION_SPOTS;
                        
                        
                    ELSE -- IF FREE_SPOTS_IN_LOCATION = 0 ZDEJMUJEMY LOCKA OD RAZU BO NIC TU NIE DODAJEMY
                        RELEASE_LOCK_RET_CODE := RELEASE_LOCK_LOCATION(CURRENT_LOCATION_ID);
                        CASE RELEASE_LOCK_RET_CODE
                            WHEN 0 THEN
                                DBMS_OUTPUT.PUT_LINE('LOCK ON LOCATION_ID '||CURRENT_LOCATION_ID||' RELEASED AS IT HAS NO FREE SPOTS');
                            WHEN 3 THEN
                                RAISE LOCK_REL_PARAMETER_ERR;
                            WHEN 4 THEN
                                RAISE LOCK_ALREADY_RELEASED;
                            WHEN 5 THEN
                                RAISE LOCK_REL_ILLEGAL_HANDLE;
                        END CASE;
                    END IF;
                    
                WHEN 1 THEN -- TIMEOUT
                    DBMS_OUTPUT.PUT_LINE('TIMEOUT TRYING TO LOCK LOCATION ' || TO_CHAR(LOCATION_ID_ARRAY(I)));
                WHEN 2 THEN -- DEADLOCK
                    RAISE LOCK_DEADLOCK;
                WHEN 3 THEN -- PARAMETER ERROR
                    RAISE LOCK_REQ_PARAMETER_ERR;
                WHEN 4 THEN -- LOKALIZACJA JUZ ZABLOKOWANA
                    DBMS_OUTPUT.PUT_LINE('LOCATION ' || TO_CHAR(LOCATION_ID_ARRAY(I) || ' ALREADY LOCKED'));
                WHEN 5 THEN -- ILLEGAL LOCKHANDLE
                    RAISE LOCK_REQ_ILLEGAL_HANDLE;
            
            END CASE;
            
            -- PRZEJDZ DO KOLEJNEJ LOKALIZACJI
            I := I + 1;
            
            -- WYJATEK JEZELI SKONCZYLY SIE LOKALIZACJE
            -- A NADAL NIE ROZMIESCILISMY WSZYSTKICH KSIAZEK
            IF I > LOCATION_ID_ARRAY.LAST THEN
                RAISE RUN_OUT_OF_LOCATIONS;
            END IF;
            
            DBMS_OUTPUT.PUT_LINE('');
            
        END LOOP;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN ZERO_BOOKS THEN
            RAISE_APPLICATION_ERROR(-20005, 'NUMBER OF BOOKS TO ADD MUST BE AT LEAST 1');
            
        WHEN RUN_OUT_OF_LOCATIONS THEN
            RAISE_APPLICATION_ERROR(-20006, 'NOT ENOUGH FREE SPOTS TO PUT ALL NEW BOOKS IN');
            
        WHEN LOCK_REQ_PARAMETER_ERR THEN
            RAISE_APPLICATION_ERROR(-20010, 'PARAMETER ERROR WHILE REQUESTING LOCK ON LOCATION_ID '
                || TO_CHAR(CURRENT_LOCATION_ID));
                
        WHEN LOCK_REL_PARAMETER_ERR THEN
            RAISE_APPLICATION_ERROR(-20016, 'PARAMETER ERROR WHILE RELEASING LOCK ON LOCATION_ID '
                || TO_CHAR(CURRENT_LOCATION_ID));
                
        WHEN LOCK_ALREADY_RELEASED THEN
            RAISE_APPLICATION_ERROR(-20011, 'LOCK ON LOCATION_ID ' || TO_CHAR(CURRENT_LOCATION_ID)
                || ' ALREADY RELEASED');
                
        WHEN LOCK_REQ_ILLEGAL_HANDLE THEN
            RAISE_APPLICATION_ERROR(-20012, 'ILLEGAL LOCKHANDLE WHILE REQUESTING LOCK ON LOCATION_ID '
                || TO_CHAR(CURRENT_LOCATION_ID));
                
        WHEN LOCK_REL_ILLEGAL_HANDLE THEN
            RAISE_APPLICATION_ERROR(-20017, 'ILLEGAL LOCKHANDLE WHILE RELEASING LOCK ON LOCATION_ID '
                || TO_CHAR(CURRENT_LOCATION_ID));
                
        WHEN LOCK_DEADLOCK THEN
            RAISE_APPLICATION_ERROR(-20015, 'DEADLOCK WHILE REQUESTING LOCK ON LOCATION_ID '
                || TO_CHAR(CURRENT_LOCATION_ID));
                
    END GET_LOCATION_LIST;
    
    -- ==================================================================
    FUNCTION ADD_BOOK (BOOK_TO_ADD BOOK_RECORD) 
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        BOOK_VALUE_WRONG EXCEPTION;
        CONDITION_WRONG EXCEPTION;
        BUY_DATE_WRONG EXCEPTION;
        LOCATION_WRONG EXCEPTION;
        CHECK_VAR NUMBER;
    BEGIN
        IF NOT(BOOK_TO_ADD.BOOK_VALUE > 0) THEN RAISE BOOK_VALUE_WRONG; END IF;
        IF NOT(BOOK_TO_ADD.CONDITION BETWEEN 1 AND 5) THEN RAISE CONDITION_WRONG; END IF;
        IF NOT(BOOK_TO_ADD.BUY_DATE >= TO_DATE('2022-09-01', 'YYYY-MM-DD')) THEN RAISE BUY_DATE_WRONG; END IF;
        
        SELECT COUNT(LOCATION_ID) INTO CHECK_VAR FROM LOCATIONS
        WHERE LOCATION_ID = BOOK_TO_ADD.LOCATION_ID;
        
        IF CHECK_VAR != 1 THEN RAISE LOCATION_WRONG; END IF;
    
        INSERT INTO BOOKS (TITLE_ID, BORROW_STATE, LOCATION_ID, BOOK_VALUE, CONDITION, BUY_DATE)
        VALUES (BOOK_TO_ADD.TITLE_ID, 'IN STORAGE', BOOK_TO_ADD.LOCATION_ID, 
        BOOK_TO_ADD.BOOK_VALUE, BOOK_TO_ADD.CONDITION, BOOK_TO_ADD.BUY_DATE)
        RETURNING BOOK_ID INTO TO_RETURN;
        
        UPDATE LOCATIONS SET EMPTY_SPOTS_LEFT = EMPTY_SPOTS_LEFT - 1
        WHERE LOCATION_ID = BOOK_TO_ADD.LOCATION_ID;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN BOOK_VALUE_WRONG THEN
            RAISE_APPLICATION_ERROR(-20007, 'BOOK VALUE MUST BE POSITIVE');
        WHEN CONDITION_WRONG THEN
            RAISE_APPLICATION_ERROR(-20008, 'CONDITION MUST BE BETWEEN 1 AND 5');
        WHEN BUY_DATE_WRONG THEN
            RAISE_APPLICATION_ERROR(-20009, 'BUY DATE MUST BE LATER THAN OR EQUAL TO SEP 1, 2022');
        WHEN LOCATION_WRONG THEN
             RAISE_APPLICATION_ERROR(-20018, 'LOCATION_ID ' || TO_CHAR(BOOK_TO_ADD.LOCATION_ID) || ' NOT FOUND');
    END ADD_BOOK;
    
    FUNCTION ADD_BOOK (TITLE_ID NUMBER, LOCATION_ID NUMBER, BOOK_VALUE NUMBER, 
        CONDITION NUMBER, BUY_DATE DATE)
        RETURN NUMBER
    AS
        TO_RETURN NUMBER;
        BOOK_TO_ADD BOOK_RECORD;
    BEGIN
        BOOK_TO_ADD := BOOK_RECORD(TITLE_ID, LOCATION_ID, BOOK_VALUE, CONDITION,
        BUY_DATE);
        TO_RETURN := ADD_BOOK(BOOK_TO_ADD);
        RETURN TO_RETURN;
    END ADD_BOOK;
    
    -- ==================================================================
    FUNCTION ADD_BOOKS (TITLE_ID NUMBER,
        ADDED_BOOKS_LOCATIONS LOCATIONS_DICTIONARY,
        HOW_MANY_BOOKS NUMBER,
        ADDED_BOOKS_VALUE NUMBER,
        ADDED_BOOKS_CONDITION NUMBER,
        ADDED_BOOKS_BUY_DATE DATE
    ) RETURN ID_ARRAY
    AS
        TO_RETURN ID_ARRAY := ID_ARRAY();
        CURRENT_BOOK_ID NUMBER;
        CURRENT_LOCATION_ID NUMBER := ADDED_BOOKS_LOCATIONS(1).LOCATION_ID;
        BOOKS_LEFT NUMBER := HOW_MANY_BOOKS;
        LOCATION_INDEX NUMBER := 0;
        SPOTS_LEFT NUMBER := ADDED_BOOKS_LOCATIONS(1).NUMBER_OF_EMPTY_SPOTS;
        BOOK_TO_ADD BOOK_RECORD;
        RELEASE_LOCK_LOCATION_RET_CODE INTEGER;
        PREV_LOCATION_ID NUMBER;
        
        LOCK_ALREADY_RELEASED EXCEPTION;
        LOCK_REL_PARAMETER_ERR EXCEPTION;
        LOCK_REL_ILLEGAL_HANDLE EXCEPTION;
    BEGIN
        WHILE BOOKS_LEFT > 0 LOOP

            LOCATION_INDEX := LOCATION_INDEX + 1;
            
            DBMS_OUTPUT.PUT_LINE('CURRENT LOCATION_ID: ' ||
                ADDED_BOOKS_LOCATIONS(LOCATION_INDEX).LOCATION_ID);
            DBMS_OUTPUT.PUT_LINE('');
            
            SPOTS_LEFT := ADDED_BOOKS_LOCATIONS(LOCATION_INDEX).NUMBER_OF_EMPTY_SPOTS;
        
            -- JEZELI NIE MA MIEJSCA W DANEJ LOKALIZACJI, SPROBUJ KOLEJNA
            WHILE SPOTS_LEFT > 0 AND BOOKS_LEFT > 0 LOOP
                DBMS_OUTPUT.PUT_LINE('LOCATION INDEX: ' || LOCATION_INDEX);
                DBMS_OUTPUT.PUT_LINE('SPOTS LEFT HERE: ' || SPOTS_LEFT);
                
                -- ZAPISZ OBECNE LOCATION_ID
                CURRENT_LOCATION_ID := ADDED_BOOKS_LOCATIONS(LOCATION_INDEX).LOCATION_ID;
                
                -- PRZYGOTUJ KROTKE POJEDYNCZEJ KSIAZKI DO DODANIA
                BOOK_TO_ADD := BOOK_RECORD(TITLE_ID, CURRENT_LOCATION_ID,
                ADDED_BOOKS_VALUE, ADDED_BOOKS_CONDITION, ADDED_BOOKS_BUY_DATE);
                
                -- DODAJ KROTKE POJEDYNCZEJ KSIAZKI
                CURRENT_BOOK_ID := ADD_BOOK(BOOK_TO_ADD);
                
                -- DOPISZ ID DODANEJ KSIAZKI DO LISTY ID
                TO_RETURN.EXTEND(1);
                TO_RETURN(TO_RETURN.LAST) := CURRENT_BOOK_ID;
                
                BOOKS_LEFT := BOOKS_LEFT - 1;
                SPOTS_LEFT := SPOTS_LEFT - 1;
                
                DBMS_OUTPUT.PUT_LINE('JUST ADDED BOOK ID: ' || CURRENT_BOOK_ID);
                DBMS_OUTPUT.PUT_LINE('BOOKS LEFT TO ADD: ' || BOOKS_LEFT);
                DBMS_OUTPUT.PUT_LINE('');
            END LOOP;
            
            PREV_LOCATION_ID := ADDED_BOOKS_LOCATIONS(LOCATION_INDEX).LOCATION_ID;
            
            RELEASE_LOCK_LOCATION_RET_CODE := 
                RELEASE_LOCK_LOCATION(PREV_LOCATION_ID);
                
            CASE RELEASE_LOCK_LOCATION_RET_CODE
                WHEN 0 THEN
                    DBMS_OUTPUT.PUT_LINE(' LOCK ON LOCATION_ID ' || TO_CHAR(PREV_LOCATION_ID)
                        || ' SUCCESSFULLY RELEASED');
                WHEN 3 THEN
                    RAISE LOCK_REL_PARAMETER_ERR;
                WHEN 4 THEN
                    RAISE LOCK_ALREADY_RELEASED;
                WHEN 5 THEN
                    RAISE LOCK_REL_ILLEGAL_HANDLE;
            END CASE;
            DBMS_OUTPUT.PUT_LINE('');
            
        END LOOP;
        
        RETURN TO_RETURN;
    EXCEPTION
        WHEN LOCK_REL_PARAMETER_ERR THEN
            RAISE_APPLICATION_ERROR(-20016, 'PARAMETER ERROR WHILE RELEASING LOCK ON LOCATION_ID '
                || TO_CHAR(PREV_LOCATION_ID));
                
        WHEN LOCK_ALREADY_RELEASED THEN
            RAISE_APPLICATION_ERROR(-20011, 'LOCK ON LOCATION_ID ' || TO_CHAR(PREV_LOCATION_ID)
                || ' ALREADY RELEASED');
                
        WHEN LOCK_REL_ILLEGAL_HANDLE THEN
            RAISE_APPLICATION_ERROR(-20017, 'ILLEGAL LOCKHANDLE WHILE RELEASING LOCK ON LOCATION_ID '
                || TO_CHAR(PREV_LOCATION_ID));
    END ADD_BOOKS;
    
    -- ==================================================================
    FUNCTION LOCK_LOCATION (T_LOCATION_ID NUMBER, T_TIMEOUT INTEGER := 1) 
    RETURN INTEGER
    IS
        T_LOCKNAME VARCHAR2(128) := 'LOCATION_LOCK_' || TO_CHAR(T_LOCATION_ID);
        T_LOCKHANDLE VARCHAR2(128);
        WRONG_LOCATION_ID EXCEPTION;
        LOCATION_CHECK NUMBER;
    BEGIN
        SELECT COUNT(LOCATION_ID) INTO LOCATION_CHECK FROM LOCATIONS
        WHERE LOCATION_ID = T_LOCATION_ID;
        
        IF LOCATION_CHECK != 1 THEN RAISE WRONG_LOCATION_ID; END IF;
        
        DBMS_LOCK.ALLOCATE_UNIQUE(
                                  LOCKNAME => T_LOCKNAME
                                 ,LOCKHANDLE => T_LOCKHANDLE);
        
        RETURN DBMS_LOCK.REQUEST(
                                 LOCKHANDLE => T_LOCKHANDLE
                                ,TIMEOUT => T_TIMEOUT
                                ,RELEASE_ON_COMMIT => FALSE);
    EXCEPTION
        WHEN WRONG_LOCATION_ID THEN
            RAISE_APPLICATION_ERROR(-20019, 'LOCK REQUESTED ON NONEXISTENT LOCATION_ID ' 
                || TO_CHAR(T_LOCATION_ID));
    END LOCK_LOCATION;
    
    -- ==================================================================
    FUNCTION RELEASE_LOCK_LOCATION (T_LOCATION_ID NUMBER)
    RETURN INTEGER
    IS
        T_LOCKNAME VARCHAR2(128) := 'LOCATION_LOCK_' || TO_CHAR(T_LOCATION_ID);
        T_LOCKHANDLE VARCHAR2(128);
        WRONG_LOCATION_ID EXCEPTION;
        LOCATION_CHECK NUMBER;
    BEGIN
        SELECT COUNT(LOCATION_ID) INTO LOCATION_CHECK FROM LOCATIONS
        WHERE LOCATION_ID = T_LOCATION_ID;
        
        IF LOCATION_CHECK != 1 THEN RAISE WRONG_LOCATION_ID; END IF;
        
        DBMS_LOCK.ALLOCATE_UNIQUE(
                                  LOCKNAME => T_LOCKNAME
                                 ,LOCKHANDLE => T_LOCKHANDLE);
                                 
        RETURN DBMS_LOCK.RELEASE(
                                 LOCKHANDLE => T_LOCKHANDLE);
    EXCEPTION
        WHEN WRONG_LOCATION_ID THEN
            RAISE_APPLICATION_ERROR(-20020, 'TRYING TO RELEASE LOCK ON NONEXISTENT LOCATION_ID ' 
                || TO_CHAR(T_LOCATION_ID));
    END RELEASE_LOCK_LOCATION;
        
END RENTAL;
/